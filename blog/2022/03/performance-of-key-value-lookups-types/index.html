<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Performance of Key/Value Collections for Updating - Matthew Crews</title><meta name=Description content="Hugo theme - LoveIt"><meta property="og:title" content="Performance of Key/Value Collections for Updating"><meta property="og:description" content="I have been working on a simulation engine that requires a key/value collection for holding the flow rates through a network as part of a Push-Relabel algorithm. This is the most performance-critical code in the engine, so I needed to find the fastest way to perform a lookup, update, and store for a key/value pair. The prevailing wisdom is to use a .NET Dictionary, but I was curious how the performance would compare to the F# Map type."><meta property="og:type" content="article"><meta property="og:url" content="https://matthewcrews.com/blog/2022/03/performance-of-key-value-lookups-types/"><meta property="og:image" content="https://matthewcrews.com/logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-03-19T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-08T10:51:52-07:00"><meta property="og:site_name" content="Matthew Crews"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://matthewcrews.com/logo.png"><meta name=twitter:title content="Performance of Key/Value Collections for Updating"><meta name=twitter:description content="I have been working on a simulation engine that requires a key/value collection for holding the flow rates through a network as part of a Push-Relabel algorithm. This is the most performance-critical code in the engine, so I needed to find the fastest way to perform a lookup, update, and store for a key/value pair. The prevailing wisdom is to use a .NET Dictionary, but I was curious how the performance would compare to the F# Map type."><meta name=application-name content="Mathew Crews"><meta name=apple-mobile-web-app-title content="Mathew Crews"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://matthewcrews.com/blog/2022/03/performance-of-key-value-lookups-types/><link rel=prev href=https://matthewcrews.com/blog/2022/02/high-performance-observation-tracking/><link rel=next href=https://matthewcrews.com/blog/2022/03/performance-of-dus-and-active-patterns/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Performance of Key/Value Collections for Updating","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/matthewcrews.com\/blog\/2022\/03\/performance-of-key-value-lookups-types\/"},"image":[{"@type":"ImageObject","url":"https:\/\/matthewcrews.com\/images\/Apple-Devices-Preview.png","width":3200,"height":2048}],"genre":"blog","wordcount":2921,"url":"https:\/\/matthewcrews.com\/blog\/2022\/03\/performance-of-key-value-lookups-types\/","datePublished":"2022-03-19T00:00:00+00:00","dateModified":"2023-05-08T10:51:52-07:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/matthewcrews.com\/images\/fast_fsharp_avatar.png"},"author":{"@type":"Person","name":"Matthew Crews"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Matthew Crews">Matthew Crews</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/blog/>Blog </a><a class=menu-item href=/about/>About </a><a class=menu-item href=https://github.com/matthewcrews/blog title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Matthew Crews">Matthew Crews</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/blog/ title>Blog</a><a class=menu-item href=/about/ title>About</a><a class=menu-item href=https://github.com/matthewcrews/blog title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page single special"><h1 class="single-title animate__animated animate__pulse animate__faster">Performance of Key/Value Collections for Updating</h1><div class=content id=content><p>I have been working on a simulation engine that requires a key/value collection for holding the flow rates through a network as part of a <a href=https://en.wikipedia.org/wiki/Push%E2%80%93relabel_maximum_flow_algorithm target=_blank rel="noopener noreffer">Push-Relabel algorithm</a>. This is the most performance-critical code in the engine, so I needed to find the fastest way to perform a lookup, update, and store for a key/value pair. The prevailing wisdom is to use a .NET <code>Dictionary</code>, but I was curious how the performance would compare to the F# <code>Map</code> type. A <code>Map</code> is backed by an <a href=https://en.wikipedia.org/wiki/AVL_tree target=_blank rel="noopener noreffer">AVL Tree</a> and has a read and write performance of $O(log(n))$ while <code>Dictionary</code> is a <a href=https://en.wikipedia.org/wiki/Hash_table target=_blank rel="noopener noreffer">Hash Table</a> with an algorithmic complexity of $O(1)$ for reads and writes.</p><p>For my use case, I need to read a value from the collection, perform a minor update, and then update the value for the key in the collection.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=n>dictionary</span><span class=o>[</span><span class=n>key</span><span class=o>]</span> <span class=o>&lt;-</span> <span class=n>dictionary</span><span class=o>[</span><span class=n>key</span><span class=o>]</span> <span class=o>+</span> <span class=mi>1</span><span class=o>.</span><span class=mi>0</span> <span class=c1>// Trivial work example
</span></span></span></code></pre></td></tr></table></div></div><h2 id=test--setup>Test Setup</h2><p>To make it easier to set up tests across various collection sizes in <code>benchmarkDotNet,</code> I defined an Enum <code>Size</code> that would indicate the size of the collection I wanted to test against.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=c1>// Enum for the different size
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>[&lt;</span><span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>Size</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>``10``</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>``100``</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>``1_000``</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>``10_000``</span> <span class=o>=</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>``100_000``</span> <span class=o>=</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>``1_000_000``</span> <span class=o>=</span> <span class=mi>5</span>
</span></span></code></pre></td></tr></table></div></div><p>The Enum cases will map to the index of the data set that I want to test against. I now define a <code>Benchmark</code> class to hold my tests and generate the necessary data.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>type</span> <span class=nc>Benchmarks</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// The number of lookups I will perform in each test
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>let</span> <span class=nv>lookupCount</span> <span class=o>=</span> <span class=mi>10</span>
</span></span><span class=line><span class=cl>    <span class=c1>// A random number generator to create random indices
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// into the collections.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>let</span> <span class=nv>rng</span> <span class=o>=</span> <span class=n>Random</span> <span class=mi>1337</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Lookup array to map Size -&gt; Count
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>let</span> <span class=nv>sizeToCount</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=o>[|</span>
</span></span><span class=line><span class=cl>            <span class=mi>10</span>
</span></span><span class=line><span class=cl>            <span class=mi>100</span>
</span></span><span class=line><span class=cl>            <span class=mi>1_000</span>
</span></span><span class=line><span class=cl>            <span class=mi>10_000</span>
</span></span><span class=line><span class=cl>            <span class=mi>100_000</span>
</span></span><span class=line><span class=cl>            <span class=mi>1_000_000</span>
</span></span><span class=line><span class=cl>        <span class=o>|]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// An array of different Maps for each size in Size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>let</span> <span class=nv>maps</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>sizeToCount</span>
</span></span><span class=line><span class=cl>        <span class=o>|&gt;</span> <span class=nn>Array</span><span class=p>.</span><span class=n>map</span> <span class=o>(</span><span class=k>fun</span> <span class=n>count</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>            <span class=n>Map</span> <span class=o>[</span><span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=mi>0</span> <span class=o>..</span> <span class=n>count</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-&gt;</span> <span class=kt>string</span> <span class=n>i</span><span class=o>,</span> <span class=mi>0</span><span class=o>.</span><span class=mi>0</span><span class=o>]</span>
</span></span><span class=line><span class=cl>            <span class=o>)</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=c1>// An array of different Dictionaries for each size in Size
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>let</span> <span class=nv>dictionaries</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>sizeToCount</span>
</span></span><span class=line><span class=cl>        <span class=o>|&gt;</span> <span class=nn>Array</span><span class=p>.</span><span class=n>map</span> <span class=o>(</span><span class=k>fun</span> <span class=n>count</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>            <span class=n>Dictionary</span> <span class=o>[</span><span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=mi>0</span> <span class=o>..</span> <span class=n>count</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-&gt;</span> <span class=n>KeyValuePair</span> <span class=o>(</span><span class=kt>string</span> <span class=n>i</span><span class=o>,</span> <span class=mi>0</span><span class=o>.</span><span class=mi>0</span><span class=o>)]</span>
</span></span><span class=line><span class=cl>            <span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>I then add a member to the <code>Benchmarks</code> class called <code>Size</code> so that <code>benchmarkDotNet</code> can update the field to automatically test across each of the cases in the <code>Size</code> Enum.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Params</span><span class=o>(</span><span class=nn>Size</span><span class=p>.</span><span class=n>``10``</span><span class=o>,</span> <span class=nn>Size</span><span class=p>.</span><span class=n>``100``</span><span class=o>,</span> <span class=nn>Size</span><span class=p>.</span><span class=n>``1_000``</span><span class=o>,</span> <span class=nn>Size</span><span class=p>.</span><span class=n>``10_000``</span><span class=o>,</span>
</span></span><span class=line><span class=cl>            <span class=nn>Size</span><span class=p>.</span><span class=n>``100_000``</span><span class=o>,</span> <span class=nn>Size</span><span class=p>.</span><span class=n>``1_000_000``</span><span class=o>)&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>member</span> <span class=k>val</span> <span class=n>Size</span> <span class=o>=</span> <span class=nn>Size</span><span class=p>.</span><span class=n>``10``</span> <span class=k>with</span> <span class=n>get</span><span class=o>,</span> <span class=n>set</span>
</span></span></code></pre></td></tr></table></div></div><p>When <code>benchmarkDotNet</code> runs, it will see that the <code>Size</code> property has been decorated with the different values we want it to test. It will run each of our tests with every value we decorate the <code>Size</code> property with.</p><p>I now create the test for the <code>Map</code> collections. I index into the <code>maps</code> array and retrieve the <code>Map</code> associated with the case of <code>Size</code>. I then retrieve the <code>keys</code> associated with the <code>Size</code>. This ensures that all of the keys we will lookup can be found in the collection. You will see that I use <code>mutable</code> on the <code>map</code> value and then return it at the end of the method. This is to ensure that the CLR doesn&rsquo;t compile the work away. This is not how I would typically use a <code>Map</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Benchmark</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>Map</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=c1>// We using mutation to ensure the compiler doesn&#39;t eliminate unnecessary work
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>let</span> <span class=nv>mutable</span> <span class=n>map</span> <span class=o>=</span> <span class=n>maps</span><span class=o>[</span><span class=n>int</span> <span class=n>b</span><span class=o>.</span><span class=n>Size</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>keys</span> <span class=o>=</span> <span class=n>keysForSize</span><span class=o>[</span><span class=n>int</span> <span class=n>b</span><span class=o>.</span><span class=n>Size</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// We are making memory access pattern as predictable as possible
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// to eliminate cache hits from the work of getting the key. We don&#39;t use
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=c1>// IEnumerable to reduce the overhead.
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>for</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>keys</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>key</span> <span class=o>=</span> <span class=n>keys</span><span class=o>[</span><span class=n>i</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>newValue</span> <span class=o>=</span> <span class=n>map</span><span class=o>[</span><span class=n>key</span><span class=o>]</span> <span class=o>+</span> <span class=mi>1</span><span class=o>.</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>        <span class=n>map</span> <span class=o>&lt;-</span> <span class=n>map</span><span class=o>.</span><span class=n>Add</span> <span class=o>(</span><span class=n>key</span><span class=o>,</span> <span class=n>newValue</span><span class=o>)</span> <span class=c1>// Do a minimal amount of work
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>map</span>
</span></span></code></pre></td></tr></table></div></div><p>We iterate through each key in the <code>keys</code> array associated with the size we are testing. I wanted to try more than one lookup, so I wasn&rsquo;t getting unexpected performance benefits from the CPU being lucky for a lookup of a single value.</p><p>I create the same test for the <code>Dictionary</code> type. The work is the same, even though it looks slightly different. This is due to <code>Dictionary</code> having a different API than <code>Map</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Benchmark</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>Dictionary</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>dictionary</span> <span class=o>=</span> <span class=n>dictionaries</span><span class=o>[</span><span class=n>int</span> <span class=n>b</span><span class=o>.</span><span class=n>Size</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>keys</span> <span class=o>=</span> <span class=n>keysForSize</span><span class=o>[</span><span class=n>int</span> <span class=n>b</span><span class=o>.</span><span class=n>Size</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>keys</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>key</span> <span class=o>=</span> <span class=n>keys</span><span class=o>[</span><span class=n>i</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=n>dictionary</span><span class=o>[</span><span class=n>key</span><span class=o>]</span> <span class=o>&lt;-</span> <span class=n>dictionary</span><span class=o>[</span><span class=n>key</span><span class=o>]</span> <span class=o>+</span> <span class=mi>1</span><span class=o>.</span><span class=mi>0</span> <span class=c1>// Do a minimal amount of work
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>dictionary</span>
</span></span></code></pre></td></tr></table></div></div><p>I now define my <code>main</code> method and run the benchmarks.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>EntryPoint</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=nv>main</span> <span class=o>_</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// I don&#39;t care about what Run returns so I&#39;m ignoring it
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>let</span> <span class=nv>_</span> <span class=o>=</span> <span class=nn>BenchmarkRunner</span><span class=p>.</span><span class=n>Run</span><span class=o>&lt;</span><span class=n>Benchmarks</span><span class=o>&gt;</span><span class=bp>()</span>
</span></span><span class=line><span class=cl>    <span class=mi>0</span>
</span></span></code></pre></td></tr></table></div></div><p>Another thing worth mentioning is that I am restricted to the <code>x64</code> platform, so I update the <code>.fsproj</code> of the project to make sure that I only build and test for <code>x64</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-xml data-lang=xml><span class=line><span class=cl><span class=nt>&lt;Project</span> <span class=na>Sdk=</span><span class=s>&#34;Microsoft.NET.Sdk&#34;</span><span class=nt>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;PropertyGroup&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;OutputType&gt;</span>Exe<span class=nt>&lt;/OutputType&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;TargetFramework&gt;</span>net6.0<span class=nt>&lt;/TargetFramework&gt;</span>
</span></span><span class=line><span class=cl><span class=c>&lt;!--    Restricts to the x64 platform--&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;Platform&gt;</span>x64<span class=nt>&lt;/Platform&gt;</span> 
</span></span><span class=line><span class=cl>  <span class=nt>&lt;/PropertyGroup&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;ItemGroup&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;Compile</span> <span class=na>Include=</span><span class=s>&#34;Program.fs&#34;</span> <span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;/ItemGroup&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;ItemGroup&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;PackageReference</span> <span class=na>Include=</span><span class=s>&#34;BenchmarkDotNet&#34;</span> <span class=na>Version=</span><span class=s>&#34;0.13.1&#34;</span> <span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl>    <span class=nt>&lt;PackageReference</span> <span class=na>Include=</span><span class=s>&#34;BenchmarkDotNet.Diagnostics.Windows&#34;</span> <span class=na>Version=</span><span class=s>&#34;0.13.1&#34;</span> <span class=nt>/&gt;</span>
</span></span><span class=line><span class=cl>  <span class=nt>&lt;/ItemGroup&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nt>&lt;/Project&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>I get the following table when I run these benchmarks with <code>dotnet run -c Release</code>.</p><table><thead><tr><th>Method</th><th>Size</th><th style=text-align:right>Mean</th><th style=text-align:right>Error</th><th style=text-align:right>StdDev</th><th style=text-align:right>Median</th></tr></thead><tbody><tr><td>Map</td><td>10</td><td style=text-align:right>986.3 ns</td><td style=text-align:right>19.51 ns</td><td style=text-align:right>38.06 ns</td><td style=text-align:right>972.5 ns</td></tr><tr><td>Dictionary</td><td>10</td><td style=text-align:right>253.2 ns</td><td style=text-align:right>3.57 ns</td><td style=text-align:right>3.17 ns</td><td style=text-align:right>252.4 ns</td></tr><tr><td>Map</td><td>100</td><td style=text-align:right>2,062.4 ns</td><td style=text-align:right>39.33 ns</td><td style=text-align:right>36.79 ns</td><td style=text-align:right>2,053.8 ns</td></tr><tr><td>Dictionary</td><td>100</td><td style=text-align:right>325.2 ns</td><td style=text-align:right>6.18 ns</td><td style=text-align:right>6.34 ns</td><td style=text-align:right>324.7 ns</td></tr><tr><td>Map</td><td>1_000</td><td style=text-align:right>3,468.0 ns</td><td style=text-align:right>68.38 ns</td><td style=text-align:right>130.09 ns</td><td style=text-align:right>3,394.7 ns</td></tr><tr><td>Dictionary</td><td>1_000</td><td style=text-align:right>299.8 ns</td><td style=text-align:right>5.99 ns</td><td style=text-align:right>10.02 ns</td><td style=text-align:right>298.1 ns</td></tr><tr><td>Map</td><td>10_000</td><td style=text-align:right>4,383.1 ns</td><td style=text-align:right>86.00 ns</td><td style=text-align:right>80.45 ns</td><td style=text-align:right>4,393.2 ns</td></tr><tr><td>Dictionary</td><td>10_000</td><td style=text-align:right>322.4 ns</td><td style=text-align:right>2.15 ns</td><td style=text-align:right>1.79 ns</td><td style=text-align:right>322.6 ns</td></tr><tr><td>Map</td><td>100_000</td><td style=text-align:right>5,571.8 ns</td><td style=text-align:right>90.32 ns</td><td style=text-align:right>84.48 ns</td><td style=text-align:right>5,569.3 ns</td></tr><tr><td>Dictionary</td><td>100_000</td><td style=text-align:right>338.0 ns</td><td style=text-align:right>2.71 ns</td><td style=text-align:right>2.26 ns</td><td style=text-align:right>338.6 ns</td></tr><tr><td>Map</td><td>1_000_000</td><td style=text-align:right>7,695.1 ns</td><td style=text-align:right>150.65 ns</td><td style=text-align:right>263.86 ns</td><td style=text-align:right>7,690.7 ns</td></tr><tr><td>Dictionary</td><td>1_000_000</td><td style=text-align:right>369.2 ns</td><td style=text-align:right>2.69 ns</td><td style=text-align:right>2.10 ns</td><td style=text-align:right>369.5 ns</td></tr></tbody></table><p>This is in alignment with my expectations. Since <code>Map</code> is an immutable data structure, it needs to copy a significant amount of data when creating the updated <code>Map</code>. This scenario is one of the worst ways you can use a <code>Map</code>. <code>Dictionary,</code> on the other hand, is a mutable data structure, so in this case, all of the work is in computing the hash code to find the correct bucket in the backing array and then the equality check to make sure the key in the bucket is the same as the one you are looking up.</p><p><code>Map</code> is a great data structure, but this is not the best use case for it. I knew this ahead of time, but it&rsquo;s good to validate your assumptions.</p><h2 id=even-faster>Even Faster?</h2><p>Can we go even faster, though? You may notice that we have to look up the key twice for each update. Once to get the value so that we can add <code>1.0</code> to it and a second time to store the updated value. It&rsquo;s all on this single line of code:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=c1>// First lookup is here to get the value to add 1.0 to it
</span></span></span><span class=line><span class=cl><span class=c1>//                             ↓
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>dictionary</span><span class=o>[</span><span class=n>key</span><span class=o>]</span> <span class=o>&lt;-</span> <span class=n>dictionary</span><span class=o>[</span><span class=n>key</span><span class=o>]</span> <span class=o>+</span> <span class=mi>1</span><span class=o>.</span><span class=mi>0</span>
</span></span><span class=line><span class=cl><span class=c1>//          ↑
</span></span></span><span class=line><span class=cl><span class=c1>// Second lookup happens here to store the value
</span></span></span></code></pre></td></tr></table></div></div><p>Wouldn&rsquo;t it be nice if we didn&rsquo;t have to do that work twice? What if instead of the <code>Dictionary</code> returning by value, it returns by reference? This way, we only need to perform the lookup once?</p><p>Now, some of you may start balking, saying that&rsquo;s dangerous. You can create some hideous bugs if you misuse this. It&rsquo;s difficult enough that you will not find it in the <code>Dictionary</code> class itself. You need to use a method found on the <code>CollectionsMarshal</code> class, in the <code>System.Runtime.InteropServices</code> namespace. The name of the method I want is <code>GetValueRefOrAddDefault</code>. This method has an unusual function signature, so I want to unpack what is happening.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=nn>CollectionsMarshal</span><span class=p>.</span><span class=n>GetValueRefOrAddDefault</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>TKey</span><span class=o>,</span><span class=k>&#39;</span><span class=n>TValue</span><span class=o>&gt;(</span><span class=n>dictionary</span><span class=o>:</span> <span class=n>Dictionary</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>TKey</span><span class=o>,</span><span class=k>&#39;</span><span class=n>TValue</span><span class=o>&gt;,</span> <span class=n>key</span><span class=o>:</span> <span class=k>&#39;</span><span class=n>TKey</span><span class=o>,</span> <span class=n>exists</span><span class=o>:</span> <span class=n>byref</span><span class=o>&lt;</span><span class=kt>bool</span><span class=o>&gt;)</span> <span class=o>:</span> <span class=n>byref</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>TValue</span>
</span></span></code></pre></td></tr></table></div></div><p>F# does some interesting things for you implicitly regarding the ref types: <code>byref</code>, <code>inref</code>, and <code>outref</code>. I highly recommend you read the Microsoft <a href=https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/byrefs target=_blank rel="noopener noreffer">docs</a> on refs. The first time you read it, you may be confused. I was, but the more I work with the ref types, the more it makes sense.</p><blockquote><p><strong>Aside:</strong> F# is designed as a succinct, expressive, and efficient language. It sometimes gets a reputation for being slow. I will concede if you write entirely idiomatic F#, your performance may not be on the level of a C++ program. BUT, that&rsquo;s not to say you can&rsquo;t write fast F# code. F# has defaults and idioms, making it easier to compose correct programs quickly.</p></blockquote><blockquote><p>What people don&rsquo;t talk about is that you can turn all the safeties in F# off if you want to. If want to drop down to raw native pointers, you can. F# forces you to be more explicit about wanting to violate the safeties which I think is a feature, not a hinderance.</p></blockquote><p>The usual way of working with a .NET API which uses a <code>byref</code> as one of the parameters for the method in F# is to use a <code>match...with</code> statement to unpack the values. The most common method I use with this behavior is the <code>TryGetValue</code> method of <code>Dictionary</code>. <code>TryGetValue</code> has the following signature:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=nn>Dictionary</span><span class=p>.</span><span class=n>TryGetValue</span><span class=o>(</span><span class=n>key</span><span class=o>:</span> <span class=kt>string</span><span class=o>,</span> <span class=n>value</span><span class=o>:</span> <span class=n>byref</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>T</span><span class=o>&gt;)</span> <span class=o>:</span> <span class=kt>bool</span>
</span></span></code></pre></td></tr></table></div></div><p>You will see that the method expects you to pass a <code>byref&lt;'T></code>. If the dictionary has the value, it will put it in the location <code>byref&lt;'T></code> points and return a <code>true</code>. If it does not find the value, it will not update the value the <code>byref&lt;'T></code> points to and returns <code>false</code>. Instead of declaring a <code>byref&lt;'T>,</code> we instead use the <code>match ... with</code> syntax, and F# will implicitly do the work of creating the <code>byref&lt;'T></code> for us.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>match</span> <span class=n>dictionary</span><span class=o>.</span><span class=n>TryGetValue</span> <span class=n>key</span> <span class=k>with</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=k>true</span><span class=o>,</span> <span class=n>value</span> <span class=o>-&gt;</span> <span class=bp>()</span> <span class=c1>// Do something with value
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=o>|</span> <span class=k>false</span><span class=o>,</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=bp>()</span> <span class=c1>// Do something without the value
</span></span></span></code></pre></td></tr></table></div></div><p><code>value</code>, in this case, will be the value that was found. It will NOT be a <code>byref&lt;'T></code> pointing to the value found. F# implicitly dereferences the <code>byref</code> for us. This implicit dereferencing is nice most of the time but, in our case, is the opposite of what we want. Therefore we must define our byrefs and pass them to the method.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=c1>// dictionary is a Dictionary&lt;int, float&gt;
</span></span></span><span class=line><span class=cl><span class=c1>// key is a `int` we are wanting to the look up the float for
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>let</span> <span class=nv>mutable</span> <span class=n>wasFound</span> <span class=o>=</span> <span class=nn>Unchecked</span><span class=p>.</span><span class=n>defaultof</span><span class=o>&lt;_&gt;</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=nv>valueRef</span> <span class=o>=</span> <span class=o>&amp;</span><span class=nn>CollectionsMarshal</span><span class=p>.</span><span class=n>GetValueRefOrAddDefault</span> <span class=o>(</span><span class=n>dictionary</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=o>&amp;</span><span class=n>wasFound</span><span class=o>)</span>
</span></span><span class=line><span class=cl><span class=c1>//             ↑ Notice this `&amp;`
</span></span></span></code></pre></td></tr></table></div></div><p><code>wasFound</code> is a <code>byref&lt;bool></code> that we pass to the method. You&rsquo;ll notice that we are not giving in a <code>byref&lt;float></code> for the method to fill in for us. Instead, we are using the <code>&</code> operator prepended to the method to tell F# that we want it to return the <code>byref</code> for us, not the value. If we did not prepend the <code>&</code> to the method call, F# would implicitly dereference the <code>byref</code> for us. This is another case of the F# defaults leaning toward safety. Fortunately, we can turn the safeties off.</p><p>Now that we know how to work with the <code>GetValueRefOrAddDefault</code> method, we create a test and compare the performance to our other tests.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Benchmark</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>DictionaryGetRef</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>dictionary</span> <span class=o>=</span> <span class=n>dictionaries</span><span class=o>[</span><span class=n>int</span> <span class=n>b</span><span class=o>.</span><span class=n>Size</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>keys</span> <span class=o>=</span> <span class=n>keysForSize</span><span class=o>[</span><span class=n>int</span> <span class=n>b</span><span class=o>.</span><span class=n>Size</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>mutable</span> <span class=n>wasFound</span> <span class=o>=</span> <span class=nn>Unchecked</span><span class=p>.</span><span class=n>defaultof</span><span class=o>&lt;_&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>keys</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>key</span> <span class=o>=</span> <span class=n>keys</span><span class=o>[</span><span class=n>i</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>valueRef</span> <span class=o>=</span> <span class=o>&amp;</span><span class=nn>CollectionsMarshal</span><span class=p>.</span><span class=n>GetValueRefOrAddDefault</span> <span class=o>(</span><span class=n>dictionary</span><span class=o>,</span> <span class=n>key</span><span class=o>,</span> <span class=o>&amp;</span><span class=n>wasFound</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=n>valueRef</span> <span class=o>&lt;-</span> <span class=n>valueRef</span> <span class=o>+</span> <span class=mi>1</span><span class=o>.</span><span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>dictionary</span>
</span></span></code></pre></td></tr></table></div></div><p>When we want to add 1.0 to our value, you&rsquo;ll notice that we don&rsquo;t have to dereference the <code>byref&lt;float></code>. F# is doing that work for us. This contrasts with C++, where you would need to dereference a pointer explicitly.</p><p>We get the following result if we run our benchmarks with this new test.</p><table><thead><tr><th>Method</th><th>Size</th><th style=text-align:right>Mean</th><th style=text-align:right>Error</th><th style=text-align:right>StdDev</th><th style=text-align:right>Median</th></tr></thead><tbody><tr><td>Map</td><td>10</td><td style=text-align:right>986.3 ns</td><td style=text-align:right>19.51 ns</td><td style=text-align:right>38.06 ns</td><td style=text-align:right>972.5 ns</td></tr><tr><td>Dictionary</td><td>10</td><td style=text-align:right>253.2 ns</td><td style=text-align:right>3.57 ns</td><td style=text-align:right>3.17 ns</td><td style=text-align:right>252.4 ns</td></tr><tr><td>DictionaryGetRef</td><td>10</td><td style=text-align:right>119.3 ns</td><td style=text-align:right>1.58 ns</td><td style=text-align:right>1.48 ns</td><td style=text-align:right>119.0 ns</td></tr><tr><td>Map</td><td>100</td><td style=text-align:right>2,062.4 ns</td><td style=text-align:right>39.33 ns</td><td style=text-align:right>36.79 ns</td><td style=text-align:right>2,053.8 ns</td></tr><tr><td>Dictionary</td><td>100</td><td style=text-align:right>325.2 ns</td><td style=text-align:right>6.18 ns</td><td style=text-align:right>6.34 ns</td><td style=text-align:right>324.7 ns</td></tr><tr><td>DictionaryGetRef</td><td>100</td><td style=text-align:right>124.5 ns</td><td style=text-align:right>2.52 ns</td><td style=text-align:right>3.10 ns</td><td style=text-align:right>124.2 ns</td></tr><tr><td>Map</td><td>1_000</td><td style=text-align:right>3,468.0 ns</td><td style=text-align:right>68.38 ns</td><td style=text-align:right>130.09 ns</td><td style=text-align:right>3,394.7 ns</td></tr><tr><td>Dictionary</td><td>1_000</td><td style=text-align:right>299.8 ns</td><td style=text-align:right>5.99 ns</td><td style=text-align:right>10.02 ns</td><td style=text-align:right>298.1 ns</td></tr><tr><td>DictionaryGetRef</td><td>1_000</td><td style=text-align:right>130.9 ns</td><td style=text-align:right>2.52 ns</td><td style=text-align:right>2.69 ns</td><td style=text-align:right>130.1 ns</td></tr><tr><td>Map</td><td>10_000</td><td style=text-align:right>4,383.1 ns</td><td style=text-align:right>86.00 ns</td><td style=text-align:right>80.45 ns</td><td style=text-align:right>4,393.2 ns</td></tr><tr><td>Dictionary</td><td>10_000</td><td style=text-align:right>322.4 ns</td><td style=text-align:right>2.15 ns</td><td style=text-align:right>1.79 ns</td><td style=text-align:right>322.6 ns</td></tr><tr><td>DictionaryGetRef</td><td>10_000</td><td style=text-align:right>141.4 ns</td><td style=text-align:right>2.12 ns</td><td style=text-align:right>1.77 ns</td><td style=text-align:right>140.9 ns</td></tr><tr><td>Map</td><td>100_000</td><td style=text-align:right>5,571.8 ns</td><td style=text-align:right>90.32 ns</td><td style=text-align:right>84.48 ns</td><td style=text-align:right>5,569.3 ns</td></tr><tr><td>Dictionary</td><td>100_000</td><td style=text-align:right>338.0 ns</td><td style=text-align:right>2.71 ns</td><td style=text-align:right>2.26 ns</td><td style=text-align:right>338.6 ns</td></tr><tr><td>DictionaryGetRef</td><td>100_000</td><td style=text-align:right>130.5 ns</td><td style=text-align:right>1.13 ns</td><td style=text-align:right>1.05 ns</td><td style=text-align:right>130.2 ns</td></tr><tr><td>Map</td><td>1_000_000</td><td style=text-align:right>7,695.1 ns</td><td style=text-align:right>150.65 ns</td><td style=text-align:right>263.86 ns</td><td style=text-align:right>7,690.7 ns</td></tr><tr><td>Dictionary</td><td>1_000_000</td><td style=text-align:right>369.2 ns</td><td style=text-align:right>2.69 ns</td><td style=text-align:right>2.10 ns</td><td style=text-align:right>369.5 ns</td></tr><tr><td>DictionaryGetRef</td><td>1_000_000</td><td style=text-align:right>152.1 ns</td><td style=text-align:right>1.09 ns</td><td style=text-align:right>0.91 ns</td><td style=text-align:right>152.1 ns</td></tr></tbody></table><p>We see that the <code>GetValueRefOrAddDefault</code> method approach is more than twice as fast. A word of warning before you go and rewrite how you use <code>Dictionary</code> though. The ref types in F# are managed pointers. This <a href=https://tooslowexception.com/managed-pointers-in-net/ target=_blank rel="noopener noreffer">article</a> by <a href=https://twitter.com/konradkokosa target=_blank rel="noopener noreffer">Konrad Kokosa</a> gives you a glimpse into the implications of managed pointers. I strongly encourage you to read the article and check out his book <a href=https://prodotnetmemory.com/ target=_blank rel="noopener noreffer">Professional .NET Memory Management</a> before you make extensive use of them.</p><h2 id=a-safer-approach>A Safer Approach</h2><p>Instead of getting a reference to the value, we could wrap our values in a <code>ValueWrapper</code> class and store those in the <code>Dictionary</code>. This was proposed in a GitHub discussion where people were debating the addition of the <code>GetValueRefOrAddDefault</code> method. I decided to code one up and compare the performance out of curiosity.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>type</span> <span class=nc>ValueWrapper</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>T</span> <span class=k>when</span> <span class=k>&#39;</span><span class=n>T</span> <span class=o>:</span> <span class=k>struct</span><span class=o>&gt;</span> <span class=o>(</span><span class=n>value</span><span class=o>:</span> <span class=k>&#39;</span><span class=n>T</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=k>val</span> <span class=n>Value</span> <span class=o>=</span> <span class=n>value</span> <span class=k>with</span> <span class=n>get</span><span class=o>,</span> <span class=n>set</span>
</span></span></code></pre></td></tr></table></div></div><p>I test this approach; I now have to wrap my values in the ValueWrapper type.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=nv>wrappedValueDictionaries</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=n>sizeToCount</span>
</span></span><span class=line><span class=cl>    <span class=o>|&gt;</span> <span class=nn>Array</span><span class=p>.</span><span class=n>map</span> <span class=o>(</span><span class=k>fun</span> <span class=n>count</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>        <span class=n>Dictionary</span> <span class=o>[</span><span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=mi>0</span> <span class=o>..</span> <span class=n>count</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-&gt;</span> <span class=n>KeyValuePair</span> <span class=o>(</span><span class=kt>string</span> <span class=n>i</span><span class=o>,</span> <span class=n>ValueWrapper</span> <span class=mi>0</span><span class=o>.</span><span class=mi>0</span><span class=o>)]</span>
</span></span><span class=line><span class=cl>        <span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>And create a test for it&mldr;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Benchmark</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>ValueWrappedDictionary</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>valueWrappedDictionary</span> <span class=o>=</span> <span class=n>wrappedValueDictionaries</span><span class=o>[</span><span class=n>int</span> <span class=n>b</span><span class=o>.</span><span class=n>Size</span><span class=o>]</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>keys</span> <span class=o>=</span> <span class=n>keysForSize</span><span class=o>[</span><span class=n>int</span> <span class=n>b</span><span class=o>.</span><span class=n>Size</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>keys</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>key</span> <span class=o>=</span> <span class=n>keys</span><span class=o>[</span><span class=n>i</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>v</span> <span class=o>=</span> <span class=n>valueWrappedDictionary</span><span class=o>[</span><span class=n>key</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=n>v</span><span class=o>.</span><span class=n>Value</span> <span class=o>&lt;-</span> <span class=n>v</span><span class=o>.</span><span class=n>Value</span> <span class=o>+</span> <span class=mi>1</span><span class=o>.</span><span class=mi>0</span> <span class=c1>// Do a minimal amount of work
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=n>valueWrappedDictionary</span>
</span></span></code></pre></td></tr></table></div></div><p>We see that this WrappedValue approach is just as fast when we run the benchmarks.</p><table><thead><tr><th>Method</th><th>Size</th><th style=text-align:right>Mean</th><th style=text-align:right>Error</th><th style=text-align:right>StdDev</th><th style=text-align:right>Median</th></tr></thead><tbody><tr><td>Map</td><td>10</td><td style=text-align:right>986.3 ns</td><td style=text-align:right>19.51 ns</td><td style=text-align:right>38.06 ns</td><td style=text-align:right>972.5 ns</td></tr><tr><td>Dictionary</td><td>10</td><td style=text-align:right>253.2 ns</td><td style=text-align:right>3.57 ns</td><td style=text-align:right>3.17 ns</td><td style=text-align:right>252.4 ns</td></tr><tr><td>ValueWrappedDictionary</td><td>10</td><td style=text-align:right>104.8 ns</td><td style=text-align:right>1.99 ns</td><td style=text-align:right>1.86 ns</td><td style=text-align:right>104.0 ns</td></tr><tr><td>DictionaryGetRef</td><td>10</td><td style=text-align:right>119.3 ns</td><td style=text-align:right>1.58 ns</td><td style=text-align:right>1.48 ns</td><td style=text-align:right>119.0 ns</td></tr><tr><td>Map</td><td>100</td><td style=text-align:right>2,062.4 ns</td><td style=text-align:right>39.33 ns</td><td style=text-align:right>36.79 ns</td><td style=text-align:right>2,053.8 ns</td></tr><tr><td>Dictionary</td><td>100</td><td style=text-align:right>325.2 ns</td><td style=text-align:right>6.18 ns</td><td style=text-align:right>6.34 ns</td><td style=text-align:right>324.7 ns</td></tr><tr><td>ValueWrappedDictionary</td><td>100</td><td style=text-align:right>132.3 ns</td><td style=text-align:right>2.08 ns</td><td style=text-align:right>1.95 ns</td><td style=text-align:right>131.7 ns</td></tr><tr><td>DictionaryGetRef</td><td>100</td><td style=text-align:right>124.5 ns</td><td style=text-align:right>2.52 ns</td><td style=text-align:right>3.10 ns</td><td style=text-align:right>124.2 ns</td></tr><tr><td>Map</td><td>1_000</td><td style=text-align:right>3,468.0 ns</td><td style=text-align:right>68.38 ns</td><td style=text-align:right>130.09 ns</td><td style=text-align:right>3,394.7 ns</td></tr><tr><td>Dictionary</td><td>1_000</td><td style=text-align:right>299.8 ns</td><td style=text-align:right>5.99 ns</td><td style=text-align:right>10.02 ns</td><td style=text-align:right>298.1 ns</td></tr><tr><td>ValueWrappedDictionary</td><td>1_000</td><td style=text-align:right>132.2 ns</td><td style=text-align:right>1.06 ns</td><td style=text-align:right>0.94 ns</td><td style=text-align:right>132.2 ns</td></tr><tr><td>DictionaryGetRef</td><td>1_000</td><td style=text-align:right>130.9 ns</td><td style=text-align:right>2.52 ns</td><td style=text-align:right>2.69 ns</td><td style=text-align:right>130.1 ns</td></tr><tr><td>Map</td><td>10_000</td><td style=text-align:right>4,383.1 ns</td><td style=text-align:right>86.00 ns</td><td style=text-align:right>80.45 ns</td><td style=text-align:right>4,393.2 ns</td></tr><tr><td>Dictionary</td><td>10_000</td><td style=text-align:right>322.4 ns</td><td style=text-align:right>2.15 ns</td><td style=text-align:right>1.79 ns</td><td style=text-align:right>322.6 ns</td></tr><tr><td>ValueWrappedDictionary</td><td>10_000</td><td style=text-align:right>150.8 ns</td><td style=text-align:right>0.90 ns</td><td style=text-align:right>0.80 ns</td><td style=text-align:right>150.6 ns</td></tr><tr><td>DictionaryGetRef</td><td>10_000</td><td style=text-align:right>141.4 ns</td><td style=text-align:right>2.12 ns</td><td style=text-align:right>1.77 ns</td><td style=text-align:right>140.9 ns</td></tr><tr><td>Map</td><td>100_000</td><td style=text-align:right>5,571.8 ns</td><td style=text-align:right>90.32 ns</td><td style=text-align:right>84.48 ns</td><td style=text-align:right>5,569.3 ns</td></tr><tr><td>Dictionary</td><td>100_000</td><td style=text-align:right>338.0 ns</td><td style=text-align:right>2.71 ns</td><td style=text-align:right>2.26 ns</td><td style=text-align:right>338.6 ns</td></tr><tr><td>ValueWrappedDictionary</td><td>100_000</td><td style=text-align:right>151.3 ns</td><td style=text-align:right>0.75 ns</td><td style=text-align:right>0.63 ns</td><td style=text-align:right>151.4 ns</td></tr><tr><td>DictionaryGetRef</td><td>100_000</td><td style=text-align:right>130.5 ns</td><td style=text-align:right>1.13 ns</td><td style=text-align:right>1.05 ns</td><td style=text-align:right>130.2 ns</td></tr><tr><td>Map</td><td>1_000_000</td><td style=text-align:right>7,695.1 ns</td><td style=text-align:right>150.65 ns</td><td style=text-align:right>263.86 ns</td><td style=text-align:right>7,690.7 ns</td></tr><tr><td>Dictionary</td><td>1_000_000</td><td style=text-align:right>369.2 ns</td><td style=text-align:right>2.69 ns</td><td style=text-align:right>2.10 ns</td><td style=text-align:right>369.5 ns</td></tr><tr><td>ValueWrappedDictionary</td><td>1_000_000</td><td style=text-align:right>153.3 ns</td><td style=text-align:right>1.21 ns</td><td style=text-align:right>1.13 ns</td><td style=text-align:right>153.2 ns</td></tr><tr><td>DictionaryGetRef</td><td>1_000_000</td><td style=text-align:right>152.1 ns</td><td style=text-align:right>1.09 ns</td><td style=text-align:right>0.91 ns</td><td style=text-align:right>152.1 ns</td></tr></tbody></table><p>The nice thing about this approach is that even when the <code>Dictionary</code> gets reorganized, our <code>ValueWrapper</code> will still point to the correct data piece. The downside is that this will allocate more memory since each <code>ValueWrapper</code> is an object that needs to be allocated on the heap. You also lose any cache locality benefits since the <code>ValueWrapper</code> objects could spread all over memory. We aren&rsquo;t observing any downsides in this tiny benchmark, but it&rsquo;s essential to be aware. There could be some performance implications in the context of a larger program.</p><p>If you feel like playing with the code yourself, you can find all the tests <a href=https://github.com/matthewcrews/KeyValueLookupPerformance target=_blank rel="noopener noreffer">here</a>. Let me know if you have ideas for going faster or other collections I should test. I can be found on <a href=https://twitter.com/McCrews target=_blank rel="noopener noreffer">Twitter</a> @McCrews, or you can email <code>matthew@crews.email</code>.</p></div><div id=comments></div></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.111.3">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2019 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=matthewcrews.com target=_blank>Matthew Crews</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"PASDMWALPK",algoliaIndex:"index.en",algoliaSearchKey:"b42948e51daaa93df92381c8e2ac0f93",highlightTag:"em",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>