<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Performance of Discriminated Unions and Active Patterns - Matthew Crews</title><meta name=Description content="Hugo theme - LoveIt"><meta property="og:title" content="Performance of Discriminated Unions and Active Patterns"><meta property="og:description" content="Part of my work is writing algorithms to analyze networks of nodes representing manufacturing systems. Each node can be one of four different types: Buffer, Constraint, Merge, and Split. A manufacturing system that we would want to simulate is typically made up of no more than 100 of these nodes. A natural way to encode these types would be to use Discriminated Unions (DU). I also use Units of Measure to annotate integers that are the ids for these manufacturing nodes."><meta property="og:type" content="article"><meta property="og:url" content="https://matthewcrews.com/blog/2022/03/performance-of-dus-and-active-patterns/"><meta property="og:image" content="https://matthewcrews.com/logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-03-20T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-05T00:01:17-07:00"><meta property="og:site_name" content="Matthew Crews"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://matthewcrews.com/logo.png"><meta name=twitter:title content="Performance of Discriminated Unions and Active Patterns"><meta name=twitter:description content="Part of my work is writing algorithms to analyze networks of nodes representing manufacturing systems. Each node can be one of four different types: Buffer, Constraint, Merge, and Split. A manufacturing system that we would want to simulate is typically made up of no more than 100 of these nodes. A natural way to encode these types would be to use Discriminated Unions (DU). I also use Units of Measure to annotate integers that are the ids for these manufacturing nodes."><meta name=application-name content="Mathew Crews"><meta name=apple-mobile-web-app-title content="Mathew Crews"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://matthewcrews.com/blog/2022/03/performance-of-dus-and-active-patterns/><link rel=prev href=https://matthewcrews.com/blog/2022/03/performance-of-key-value-lookups-types/><link rel=next href=https://matthewcrews.com/blog/2022/12/fast-enumeration-of-bitset/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Performance of Discriminated Unions and Active Patterns","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/matthewcrews.com\/blog\/2022\/03\/performance-of-dus-and-active-patterns\/"},"image":[{"@type":"ImageObject","url":"https:\/\/matthewcrews.com\/images\/Apple-Devices-Preview.png","width":3200,"height":2048}],"genre":"blog","wordcount":2444,"url":"https:\/\/matthewcrews.com\/blog\/2022\/03\/performance-of-dus-and-active-patterns\/","datePublished":"2022-03-20T00:00:00+00:00","dateModified":"2023-05-05T00:01:17-07:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/matthewcrews.com\/images\/fast_fsharp_avatar.png"},"author":{"@type":"Person","name":"Matthew Crews"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Matthew Crews">Matthew Crews</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/blog/>Blog </a><a class=menu-item href=/about/>About </a><a class=menu-item href=https://github.com/matthewcrews/blog title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Matthew Crews">Matthew Crews</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/blog/ title>Blog</a><a class=menu-item href=/about/ title>About</a><a class=menu-item href=https://github.com/matthewcrews/blog title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page single special"><h1 class="single-title animate__animated animate__pulse animate__faster">Performance of Discriminated Unions and Active Patterns</h1><div class=content id=content><p>Part of my work is writing algorithms to analyze networks of nodes representing manufacturing systems. Each node can be one of four different types: Buffer, Constraint, Merge, and Split. A manufacturing system that we would want to simulate is typically made up of no more than 100 of these nodes. A natural way to encode these types would be to use Discriminated Unions (DU). I also use Units of Measure to annotate integers that are the ids for these manufacturing nodes.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Measure</span><span class=o>&gt;]</span> <span class=k>type</span> <span class=nc>BufferId</span>
</span></span><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Measure</span><span class=o>&gt;]</span> <span class=k>type</span> <span class=nc>ConstraintId</span>
</span></span><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Measure</span><span class=o>&gt;]</span> <span class=k>type</span> <span class=nc>SplitId</span>
</span></span><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Measure</span><span class=o>&gt;]</span> <span class=k>type</span> <span class=nc>MergeId</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>RequireQualifiedAccess</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>Node</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>BufferId</span> <span class=k>of</span> <span class=n>bufferId</span> <span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=n>BufferId</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>ConstraintId</span> <span class=k>of</span> <span class=n>constraintId</span> <span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=n>ConstraintId</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>MergeId</span> <span class=k>of</span> <span class=n>mergeId</span> <span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=n>MergeId</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>SplitId</span> <span class=k>of</span> <span class=n>splitId</span> <span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=n>SplitId</span><span class=o>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>The default encoding for a DU in F# is as a reference type. This means that if you have a <code>Node array</code>, each array element will be a pointer to where the <code>Node</code> itself is stored in memory. If you need to quickly lookup up Nodes and what type they are, you can run into a phenomenon known as Pointer Chasing. Pointer Chasing is when the CPU is trying to run your code but constantly has to look up new regions of memory because the data is spread out. As .NET developers, we tend not to think about this much, but it can become a severe problem in performance-sensitive code.</p><p>Fortunately, F# allows us to encode DUs as structs using the <code>[&lt;Struct>]</code> attribute. Here is what that looks like:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Struct</span><span class=o>;</span> <span class=n>RequireQualifiedAccess</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>Node</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>BufferId</span> <span class=k>of</span> <span class=n>bufferId</span> <span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=n>BufferId</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>ConstraintId</span> <span class=k>of</span> <span class=n>constraintId</span> <span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=n>ConstraintId</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>MergeId</span> <span class=k>of</span> <span class=n>mergeId</span> <span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=n>MergeId</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>SplitId</span> <span class=k>of</span> <span class=n>splitId</span> <span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=n>SplitId</span><span class=o>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>Now, if you have a <code>Node array</code>, the data for the node will be stored in the array itself so you can eliminate having to perform an additional lookup. There is a serious downside to this, though. The F# compiler will allocate space for each possible case of the DU instead of only the area necessary for the instantiated individual case. This means that instead of just taking up the space of just two <code>int</code> (one to encode the case and one for the value), this struct <code>Node</code> will take up one <code>int</code> to encode the case and four more <code>int</code> for each possible case. For a deeper explanation of this, I refer you to <a href=https://bartoszsypytkowski.com/writing-high-performance-f-code/ target=_blank rel="noopener noreffer">this</a> excellent post by <a href=https://bartoszsypytkowski.com/ target=_blank rel="noopener noreffer">Bartosz Sypytkowski</a>. If a DU has too many cases, the benefits of the struct layout will quickly be negated by this padding.</p><h2 id=alternative-encoding>Alternative Encoding</h2><p>I was curious if there was another way to approach my problem. I like the elegance of the <code>match ... with</code> syntax in F#, and I am loathed to give it up. Since my <code>Node</code> type is just encoding different possible <code>int</code> values, why not do some bit hacking? Now, I will be the first to say this is non-traditional F# code, but I&rsquo;m curious, so why not perform the experiment?</p><p>I&rsquo;ll define a new version of <code>Node</code> that will use an <code>int</code> to hold the data about which case it represents and the value. I will use the last 4 bits of the <code>Value</code> field to encode which case the <code>Node</code> represents and the top 28 bits will hold the id value. This is cutting off some of the space that <code>int</code> can express, but since our networks are never more than 1,000 nodes, there is no practical loss of modeling space.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>Node</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    	<span class=n>Value</span> <span class=o>:</span> <span class=n>int</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>member</span> <span class=n>BufferIdCode</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>member</span> <span class=n>ConstraintIdCode</span> <span class=o>=</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>member</span> <span class=n>MergeIdCode</span> <span class=o>=</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>member</span> <span class=n>SplitIdCode</span> <span class=o>=</span> <span class=mi>3</span>
</span></span></code></pre></td></tr></table></div></div><p>The static members <code>BufferIdCode</code>, <code>ConstraintIdCode</code>, <code>MergeIdCode</code>, and <code>SplitIdCode,</code> will be the values I use to encode the Node cases. To still use the <code>match...with</code> syntax, I will need to define an <a href=https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns target=_blank rel="noopener noreffer">Active Pattern</a> for unpacking the case. Active Patterns are an elegant feature of F# for decomposing data into different forms. In this case, I will take the <code>int</code> held in my <code>Node</code> type, check which case it is, and then return the corresponding id.</p><p>I use a mask and a bitwise AND operation to get the last 4 bits (also known as a nibble) of the <code>Value</code> field, which gives me an <code>int</code>. I compare that <code>int</code> with the possible code values to figure out which type of node it is. I then bit shift the <code>Value</code> field to the right 4 bits to convert it to the id value it stores and multiply the result by the right Unit of Measure to ensure type safety.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=o>(|</span><span class=n>BufferId</span><span class=o>|</span><span class=n>ConstraintId</span><span class=o>|</span><span class=n>SplitId</span><span class=o>|</span><span class=n>MergeId</span><span class=o>|)</span> <span class=o>(</span><span class=n>node</span><span class=o>:</span> <span class=n>Node</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Get the nibble which encodes the type of Id
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>let</span> <span class=nv>nodeType</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>Value</span> <span class=o>&amp;&amp;&amp;</span> <span class=mi>0</span><span class=n>x0000000F</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Get the value of the Id
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>let</span> <span class=nv>idValue</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>Value</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>nodeType</span> <span class=o>=</span> <span class=nn>Node</span><span class=p>.</span><span class=n>BufferIdCode</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>        <span class=n>BufferId</span> <span class=o>(</span><span class=n>idValue</span> <span class=o>*</span> <span class=mi>1</span><span class=o>&lt;</span><span class=n>BufferId</span><span class=o>&gt;)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>nodeType</span> <span class=o>=</span> <span class=nn>Node</span><span class=p>.</span><span class=n>ConstraintIdCode</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>        <span class=n>ConstraintId</span> <span class=o>(</span><span class=n>idValue</span> <span class=o>*</span> <span class=mi>1</span><span class=o>&lt;</span><span class=n>ConstraintId</span><span class=o>&gt;)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>nodeType</span> <span class=o>=</span> <span class=nn>Node</span><span class=p>.</span><span class=n>MergeIdCode</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>        <span class=n>MergeId</span> <span class=o>(</span><span class=n>idValue</span> <span class=o>*</span> <span class=mi>1</span><span class=o>&lt;</span><span class=n>MergeId</span><span class=o>&gt;)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>elif</span> <span class=n>nodeType</span> <span class=o>=</span> <span class=nn>Node</span><span class=p>.</span><span class=n>SplitIdCode</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>        <span class=n>SplitId</span> <span class=o>(</span><span class=n>idValue</span> <span class=o>*</span> <span class=mi>1</span><span class=o>&lt;</span><span class=n>SplitId</span><span class=o>&gt;)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>invalidArg</span> <span class=o>(</span><span class=n>nameof</span> <span class=n>node</span><span class=o>)</span> <span class=s>&#34;Node Id type does not match known Node Types&#34;</span>
</span></span></code></pre></td></tr></table></div></div><p>There is a downside to this technique, though. Active Patterns will cause additional allocations and trigger additional Garbage Collection (GC). Fortunately, F# recognized this and enabled the returning of a struct from a <a href=https://docs.microsoft.com/en-us/dotnet/fsharp/language-reference/active-patterns#struct-representations-for-partial-active-patterns target=_blank rel="noopener noreffer">Partial Active Pattern</a>. The syntax is a little odd due to a limitation in the compiler, but it works for our purposes.</p><p>Here is the equivalent approach using the Partial Active Pattern that returns a <code>ValueStruct</code> to reduce GC pressure. Compared to our first Active Pattern, the downside is that we have to define a separate one for each case we want to match against.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=k>return</span><span class=o>:</span> <span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=o>(|</span><span class=n>BufferId</span><span class=o>|_|)</span> <span class=o>(</span><span class=n>node</span><span class=o>:</span> <span class=n>Node</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>nodeType</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>Value</span> <span class=o>&amp;&amp;&amp;</span> <span class=mi>0</span><span class=n>x0000000F</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>nodeType</span> <span class=o>=</span> <span class=nn>Node</span><span class=p>.</span><span class=n>BufferIdCode</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>idValue</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>Value</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>        <span class=n>ValueSome</span> <span class=o>(</span><span class=n>idValue</span> <span class=o>*</span> <span class=mi>1</span><span class=o>&lt;</span><span class=n>BufferId</span><span class=o>&gt;)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>ValueNone</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[&lt;</span><span class=k>return</span><span class=o>:</span> <span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=o>(|</span><span class=n>ConstraintId</span><span class=o>|_|)</span> <span class=o>(</span><span class=n>node</span><span class=o>:</span> <span class=n>Node</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>nodeType</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>Value</span> <span class=o>&amp;&amp;&amp;</span> <span class=mi>0</span><span class=n>x0000000F</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>nodeType</span> <span class=o>=</span> <span class=nn>Node</span><span class=p>.</span><span class=n>ConstraintIdCode</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>idValue</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>Value</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>        <span class=n>ValueSome</span> <span class=o>(</span><span class=n>idValue</span> <span class=o>*</span> <span class=mi>1</span><span class=o>&lt;</span><span class=n>ConstraintId</span><span class=o>&gt;)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>ValueNone</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[&lt;</span><span class=k>return</span><span class=o>:</span> <span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=o>(|</span><span class=n>MergeId</span><span class=o>|_|)</span> <span class=o>(</span><span class=n>node</span><span class=o>:</span> <span class=n>Node</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>nodeType</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>Value</span> <span class=o>&amp;&amp;&amp;</span> <span class=mi>0</span><span class=n>x0000000F</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>nodeType</span> <span class=o>=</span> <span class=nn>Node</span><span class=p>.</span><span class=n>MergeIdCode</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>idValue</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>Value</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>        <span class=n>ValueSome</span> <span class=o>(</span><span class=n>idValue</span> <span class=o>*</span> <span class=mi>1</span><span class=o>&lt;</span><span class=n>MergeId</span><span class=o>&gt;)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>ValueNone</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[&lt;</span><span class=k>return</span><span class=o>:</span> <span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=o>(|</span><span class=n>SplitId</span><span class=o>|_|)</span> <span class=o>(</span><span class=n>node</span><span class=o>:</span> <span class=n>Node</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>nodeType</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>Value</span> <span class=o>&amp;&amp;&amp;</span> <span class=mi>0</span><span class=n>x0000000F</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=n>nodeType</span> <span class=o>=</span> <span class=nn>Node</span><span class=p>.</span><span class=n>SplitIdCode</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>idValue</span> <span class=o>=</span> <span class=n>node</span><span class=o>.</span><span class=n>Value</span> <span class=o>&gt;&gt;&gt;</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>        <span class=n>ValueSome</span> <span class=o>(</span><span class=n>idValue</span> <span class=o>*</span> <span class=mi>1</span><span class=o>&lt;</span><span class=n>SplitId</span><span class=o>&gt;)</span>
</span></span><span class=line><span class=cl>    <span class=k>else</span>
</span></span><span class=line><span class=cl>        <span class=n>ValueNone</span>
</span></span></code></pre></td></tr></table></div></div><h2 id=benchmark-setup>Benchmark Setup</h2><p>We will now set up two types of tests. The first set of tests will randomly jump around a <code>Node array</code>, check the Node type, and perform different work based on the case. This is most similar to the workloads I experience when writing algorithms for simulating manufacturing systems. For curiosity, I will also have a tests for a linear traversal of a <code>Node array</code> and perform the same work as the random access. This should illustrate the difference in performance between a predictable access pattern and a random one. The branch predictor in the CPU will have a more challenging time with the random access, and we expect it to be slower.</p><p>To see the impact of the Active Pattern on memory allocation and GC, we will include the <code>[&lt;MemoryDiagnoser>]</code> attribute on a <code>Benchmarks</code> class that holds our tests. This will tell BenchmarkDotNet to monitor how much allocation is occurring. We should see the Active Pattern approach incur more GC activity. We also include the <code>BranchMispredictions</code> and <code>CacheMisses</code> hardware counters to see how well the CPU can optimize our code. The ideal code has <code>0</code> Branch Mispredictions. Whenever we mispredict a branch, we can lose 20 - 30 cycles worth of work depending on the CPU. Cache Misses occur when our data is not in the cache, and the CPU has to go out to memory to retrieve the data. The CPU will do its best to predict what data it needs and fetch it ahead of time. When it guesses wrong, we can incur a severe performance penalty.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>MemoryDiagnoser</span><span class=o>;</span> <span class=n>HardwareCounters</span><span class=o>(</span><span class=nn>HardwareCounter</span><span class=p>.</span><span class=n>BranchMispredictions</span><span class=o>,</span> <span class=nn>HardwareCounter</span><span class=p>.</span><span class=n>CacheMisses</span><span class=o>)&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>Benchmarks</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>rng</span> <span class=o>=</span> <span class=n>Random</span> <span class=mi>123</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>nodeCount</span> <span class=o>=</span> <span class=mi>100</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>lookupCount</span> <span class=o>=</span> <span class=mi>100</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>loopCount</span> <span class=o>=</span> <span class=mi>100_000</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>nodes</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=o>[|</span><span class=k>for</span> <span class=n>i</span> <span class=k>in</span> <span class=mi>0</span> <span class=o>..</span> <span class=n>nodeCount</span> <span class=o>-</span> <span class=mi>1</span> <span class=o>-&gt;</span>
</span></span><span class=line><span class=cl>            <span class=k>match</span> <span class=n>rng</span><span class=o>.</span><span class=n>Next</span> <span class=o>(</span><span class=mi>0</span><span class=o>,</span> <span class=mi>4</span><span class=o>)</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=mi>0</span> <span class=o>-&gt;</span> <span class=nn>DuEncoding</span><span class=p>.</span><span class=nn>Node</span><span class=p>.</span><span class=n>BufferId</span> <span class=mi>1</span><span class=o>&lt;</span><span class=n>BufferId</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=mi>1</span> <span class=o>-&gt;</span> <span class=nn>DuEncoding</span><span class=p>.</span><span class=nn>Node</span><span class=p>.</span><span class=n>ConstraintId</span> <span class=mi>1</span><span class=o>&lt;</span><span class=n>ConstraintId</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=mi>2</span> <span class=o>-&gt;</span> <span class=nn>DuEncoding</span><span class=p>.</span><span class=nn>Node</span><span class=p>.</span><span class=n>MergeId</span> <span class=mi>1</span><span class=o>&lt;</span><span class=n>MergeId</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=mi>3</span> <span class=o>-&gt;</span> <span class=nn>DuEncoding</span><span class=p>.</span><span class=nn>Node</span><span class=p>.</span><span class=n>SplitId</span> <span class=mi>1</span><span class=o>&lt;</span><span class=n>SplitId</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>failwith</span> <span class=s>&#34;The RNG generated a number outside the allowed bounds&#34;</span>
</span></span><span class=line><span class=cl>        <span class=o>|]</span>
</span></span></code></pre></td></tr></table></div></div><p>At the beginning of the <code>Benchmarks</code> class, we declare a random number generator <code>rng</code> which we will use to produce random nodes and indices to look up. We have a <code>nodeCount</code> of 100, which is the number of nodes we will generate. The <code>lookupCount</code> is the number of node lookups we will perform during each test loop. The <code>loopCount</code> is the number of loops we will perform in each test. <code>nodes</code> is an array of randomly generated nodes for our test.</p><p>Our first test performs random lookups in the <code>nodes</code> array. It matches against the case of the DU and then adds a different amount to an accumulator based on the case. This is to simulate some amount of work being done for each node that was looked up.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Benchmark</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>DuEncodingRandomAccess</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>mutable</span> <span class=n>acc</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>lookupsIndex</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>loopCount</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>lookups</span> <span class=o>=</span> <span class=n>randomNodeIndices</span><span class=o>[</span><span class=n>lookupsIndex</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>lookupIndex</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>lookups</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>randomNodeIndex</span> <span class=o>=</span> <span class=n>lookups</span><span class=o>[</span><span class=n>lookupIndex</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>match</span> <span class=n>nodes</span><span class=o>[</span><span class=n>randomNodeIndex</span><span class=o>]</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>DuEncoding</span><span class=p>.</span><span class=nn>Node</span><span class=p>.</span><span class=n>BufferId</span> <span class=n>bufferId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>DuEncoding</span><span class=p>.</span><span class=nn>Node</span><span class=p>.</span><span class=n>ConstraintId</span> <span class=n>constraintId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>DuEncoding</span><span class=p>.</span><span class=nn>Node</span><span class=p>.</span><span class=n>MergeId</span> <span class=n>mergeId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>DuEncoding</span><span class=p>.</span><span class=nn>Node</span><span class=p>.</span><span class=n>SplitId</span> <span class=n>splitId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>acc</span>
</span></span></code></pre></td></tr></table></div></div><p>The second test does the same work, but the <code>Node</code> type is the struct representation instead of the reference-based one.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Benchmark</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>StructDuEncodingRandomAccess</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>mutable</span> <span class=n>acc</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>lookupsIndex</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>loopCount</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>lookups</span> <span class=o>=</span> <span class=n>randomNodeIndices</span><span class=o>[</span><span class=n>lookupsIndex</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>lookupIndex</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>lookups</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>randomNodeIndex</span> <span class=o>=</span> <span class=n>lookups</span><span class=o>[</span><span class=n>lookupIndex</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>match</span> <span class=n>structNodes</span><span class=o>[</span><span class=n>randomNodeIndex</span><span class=o>]</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>StructDuEncoding</span><span class=p>.</span><span class=nn>Node</span><span class=p>.</span><span class=n>BufferId</span> <span class=n>bufferId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>StructDuEncoding</span><span class=p>.</span><span class=nn>Node</span><span class=p>.</span><span class=n>ConstraintId</span> <span class=n>constraintId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>StructDuEncoding</span><span class=p>.</span><span class=nn>Node</span><span class=p>.</span><span class=n>MergeId</span> <span class=n>mergeId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>StructDuEncoding</span><span class=p>.</span><span class=nn>Node</span><span class=p>.</span><span class=n>SplitId</span> <span class=n>splitId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>acc</span>
</span></span></code></pre></td></tr></table></div></div><p>The third and fourth tests also perform the same work but with the Active Pattern and Partial Active Pattern approaches. Remember, the Active Pattern allocates objects while the Partial Active Pattern is returning a struct and therefore not causing any GC overhead.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Benchmark</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>IntEncodingWithActivePatternRandomAccess</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>mutable</span> <span class=n>acc</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>lookupsIndex</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>loopCount</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>lookups</span> <span class=o>=</span> <span class=n>randomNodeIndices</span><span class=o>[</span><span class=n>lookupsIndex</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>lookupIndex</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>lookups</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>randomNodeIndex</span> <span class=o>=</span> <span class=n>lookups</span><span class=o>[</span><span class=n>lookupIndex</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>match</span> <span class=n>intEncodedNodes</span><span class=o>[</span><span class=n>randomNodeIndex</span><span class=o>]</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>IntEncoding</span><span class=p>.</span><span class=nn>ActivePattern</span><span class=p>.</span><span class=n>BufferId</span> <span class=n>bufferId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>IntEncoding</span><span class=p>.</span><span class=nn>ActivePattern</span><span class=p>.</span><span class=n>ConstraintId</span> <span class=n>constraintId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>IntEncoding</span><span class=p>.</span><span class=nn>ActivePattern</span><span class=p>.</span><span class=n>MergeId</span> <span class=n>mergeId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>IntEncoding</span><span class=p>.</span><span class=nn>ActivePattern</span><span class=p>.</span><span class=n>SplitId</span> <span class=n>splitId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>acc</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Benchmark</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>IntEncodingWithPartialActivePatternRandomAccess</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>mutable</span> <span class=n>acc</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>lookupsIndex</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>loopCount</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>lookups</span> <span class=o>=</span> <span class=n>randomNodeIndices</span><span class=o>[</span><span class=n>lookupsIndex</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>lookupIndex</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>to</span> <span class=n>lookups</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>randomNodeIndex</span> <span class=o>=</span> <span class=n>lookups</span><span class=o>[</span><span class=n>lookupIndex</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>match</span> <span class=n>intEncodedNodes</span><span class=o>[</span><span class=n>randomNodeIndex</span><span class=o>]</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>IntEncoding</span><span class=p>.</span><span class=nn>PartialActivePattern</span><span class=p>.</span><span class=n>BufferId</span> <span class=n>bufferId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>IntEncoding</span><span class=p>.</span><span class=nn>PartialActivePattern</span><span class=p>.</span><span class=n>ConstraintId</span> <span class=n>constraintId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>2</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>IntEncoding</span><span class=p>.</span><span class=nn>PartialActivePattern</span><span class=p>.</span><span class=n>MergeId</span> <span class=n>mergeId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>3</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=nn>IntEncoding</span><span class=p>.</span><span class=nn>PartialActivePattern</span><span class=p>.</span><span class=n>SplitId</span> <span class=n>splitId</span> <span class=o>-&gt;</span> <span class=n>acc</span> <span class=o>&lt;-</span> <span class=n>acc</span> <span class=o>+</span> <span class=mi>4</span>
</span></span><span class=line><span class=cl>            <span class=o>|</span> <span class=o>_</span> <span class=o>-&gt;</span> <span class=n>failwith</span> <span class=s>&#34;</span><span class=err>\</span><span class=s>_()_/&#34;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>acc</span>
</span></span></code></pre></td></tr></table></div></div><p>I also create four additional tests which perform the same amount of work as the above four, but iterate through the arrays in order instead of randomly jumping around. This will show us the performance difference between random versus sequential access.</p><h2 id=results>Results</h2><blockquote><p><strong>Note:</strong> Since I am measuring hardware counters, I have to run the terminal as admin; otherwise, I won&rsquo;t have access to the data. If you want to test this yourself, you need to do the same.</p></blockquote><p>When I run the tests, I get the following table:</p><table><thead><tr><th>Method</th><th style=text-align:right>Mean</th><th style=text-align:right>Error</th><th style=text-align:right>StdDev</th><th style=text-align:right>BranchMispredictions/Op</th><th style=text-align:right>CacheMisses/Op</th><th style=text-align:right>Gen 0</th><th style=text-align:right>Allocated</th></tr></thead><tbody><tr><td>DuEncodingRandomAccess</td><td style=text-align:right>83.09 ms</td><td style=text-align:right>1.122 ms</td><td style=text-align:right>0.995 ms</td><td style=text-align:right>7,414,534</td><td style=text-align:right>400,225</td><td style=text-align:right>-</td><td style=text-align:right>175 B</td></tr><tr><td>StructDuEncodingRandomAccess</td><td style=text-align:right>83.56 ms</td><td style=text-align:right>0.766 ms</td><td style=text-align:right>0.640 ms</td><td style=text-align:right>7,415,626</td><td style=text-align:right>409,418</td><td style=text-align:right>-</td><td style=text-align:right>175 B</td></tr><tr><td>IntEncodingWithActivePatternRandomAccess</td><td style=text-align:right>134.88 ms</td><td style=text-align:right>2.650 ms</td><td style=text-align:right>4.845 ms</td><td style=text-align:right>8,126,171</td><td style=text-align:right>1,070,592</td><td style=text-align:right>28500.0000</td><td style=text-align:right>240,000,358 B</td></tr><tr><td>IntEncodingWithPartialActivePatternRandomAccess</td><td style=text-align:right>86.43 ms</td><td style=text-align:right>0.841 ms</td><td style=text-align:right>0.787 ms</td><td style=text-align:right>7,995,620</td><td style=text-align:right>406,096</td><td style=text-align:right>-</td><td style=text-align:right>191 B</td></tr><tr><td>DuEncodingLinearAccess</td><td style=text-align:right>14.86 ms</td><td style=text-align:right>0.090 ms</td><td style=text-align:right>0.084 ms</td><td style=text-align:right>5,073</td><td style=text-align:right>7,701</td><td style=text-align:right>-</td><td style=text-align:right>22 B</td></tr><tr><td>StructDuEncodingLinearAccess</td><td style=text-align:right>17.35 ms</td><td style=text-align:right>0.151 ms</td><td style=text-align:right>0.142 ms</td><td style=text-align:right>119,799</td><td style=text-align:right>13,508</td><td style=text-align:right>-</td><td style=text-align:right>36 B</td></tr><tr><td>IntEncodingWithActivePatternLinearAccess</td><td style=text-align:right>74.67 ms</td><td style=text-align:right>1.018 ms</td><td style=text-align:right>0.903 ms</td><td style=text-align:right>167,078</td><td style=text-align:right>677,829</td><td style=text-align:right>28571.4286</td><td style=text-align:right>240,000,191 B</td></tr><tr><td>IntEncodingWithPartialActivePatternLinearAccess</td><td style=text-align:right>22.83 ms</td><td style=text-align:right>0.372 ms</td><td style=text-align:right>0.348 ms</td><td style=text-align:right>8,151</td><td style=text-align:right>33,225</td><td style=text-align:right>-</td><td style=text-align:right>45 B</td></tr></tbody></table><p>We see that the normal reference-based DU encoding gives us the best performance for both tests. This honestly surprised me. I would have thought that the Int Encoding would have yielded better results. There is some serious voodoo going on in the F# compiler. I wanted to dig into this more, but my work demands that I cut myself off here. I would like to get this info out for others to look at since I have not been able to find other blog posts which deal with this.</p><p>I welcome feedback and critique. You can find the code <a href=https://github.com/matthewcrews/ActivePatternPerformance target=_blank rel="noopener noreffer">here</a>. Let me know if I missed something obvious. Eventually, I hope to have the time to dig deeper into this. In the meantime, I plan to stick with the default DU until I can figure out if I can make something faster for my use case. Let me know if you have ideas for going faster or other ideas I should test. I can be found on <a href=https://twitter.com/McCrews target=_blank rel="noopener noreffer">Twitter</a> @McCrews, or you can email <code>matthew@crews.email</code>.</p></div><div id=comments></div></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.111.3">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2019 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=matthewcrews.com target=_blank>Matthew Crews</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"PASDMWALPK",algoliaIndex:"index.en",algoliaSearchKey:"b42948e51daaa93df92381c8e2ac0f93",highlightTag:"em",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>