<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Fast Iteration of Set Bits in BitSet - Matthew Crews</title><meta name=Description content="Hugo theme - LoveIt"><meta property="og:title" content="Fast Iteration of Set Bits in BitSet">
<meta property="og:description" content="This article is for the 2022 F# Advent Calendar
Full code for article found here
While building the Aidos engine for Discrete Rate Simulation, I often have to build custom collections to meet the project&rsquo;s performance requirements. Don&rsquo;t get me wrong, many of the collections built into .NET are great, but they are general-purpose. General-purpose collections must meet the requirements of many use cases. I have a single use case in mind for my work, and performance is one of the critical features."><meta property="og:type" content="article"><meta property="og:url" content="https://matthewcrews.com/blog/2022/12/fast-enumeration-of-bitset/"><meta property="og:image" content="https://matthewcrews.com/logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-12-01T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-17T00:23:58-08:00"><meta property="og:site_name" content="Matthew Crews"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://matthewcrews.com/logo.png"><meta name=twitter:title content="Fast Iteration of Set Bits in BitSet"><meta name=twitter:description content="This article is for the 2022 F# Advent Calendar
Full code for article found here
While building the Aidos engine for Discrete Rate Simulation, I often have to build custom collections to meet the project&rsquo;s performance requirements. Don&rsquo;t get me wrong, many of the collections built into .NET are great, but they are general-purpose. General-purpose collections must meet the requirements of many use cases. I have a single use case in mind for my work, and performance is one of the critical features."><meta name=twitter:site content="@xxxx"><meta name=application-name content="Mathew Crews"><meta name=apple-mobile-web-app-title content="Mathew Crews"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://matthewcrews.com/blog/2022/12/fast-enumeration-of-bitset/><link rel=prev href=https://matthewcrews.com/blog/2022/03/performance-of-dus-and-active-patterns/><link rel=next href=https://matthewcrews.com/blog/2023/05/what-is-going-on-with-software/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Fast Iteration of Set Bits in BitSet","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/matthewcrews.com\/blog\/2022\/12\/fast-enumeration-of-bitset\/"},"image":[{"@type":"ImageObject","url":"https:\/\/matthewcrews.com\/images\/Apple-Devices-Preview.png","width":3200,"height":2048}],"genre":"blog","wordcount":3167,"url":"https:\/\/matthewcrews.com\/blog\/2022\/12\/fast-enumeration-of-bitset\/","datePublished":"2022-12-01T00:00:00+00:00","dateModified":"2023-12-17T00:23:58-08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/matthewcrews.com\/images\/fast_fsharp_avatar.png"},"author":{"@type":"Person","name":"Matthew Crews"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Matthew Crews">Matthew Crews</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/blog/>Blog </a><a class=menu-item href=/about/>About </a><a class=menu-item href=https://github.com/matthewcrews/blog title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Matthew Crews">Matthew Crews</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/blog/ title>Blog</a><a class=menu-item href=/about/ title>About</a><a class=menu-item href=https://github.com/matthewcrews/blog title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page single special"><h1 class="single-title animate__animated animate__pulse animate__faster">Fast Iteration of Set Bits in BitSet</h1><div class=content id=content><blockquote><p>This article is for the 2022 F# Advent Calendar</p></blockquote><blockquote><p>Full code for article found <a href=https://github.com/matthewcrews/FSharpPerformance/tree/main/BitSetEnumeration target=_blank rel="noopener noreffer">here</a></p></blockquote><p>While building the Aidos engine for Discrete Rate Simulation, I often have to build custom collections to meet the project&rsquo;s performance requirements. Don&rsquo;t get me wrong, many of the collections built into .NET are great, but they are general-purpose. General-purpose collections must meet the requirements of many use cases. I have a single use case in mind for my work, and performance is one of the critical features. If our engine isn&rsquo;t orders of magnitude faster than the competition, we don&rsquo;t have a compelling product.</p><p>In Aidos, I often need to track items that have changed during a time step of the simulation. I also track entities with an <code>int</code> that has been annotated with a Unit of Measure. This means an entity ends up being an <code>int&lt;'EntityType></code>. I also cannot have duplicates for my use case, so I need to maintain a distinct set of entities that have changed. One way to do this would be to use a <code>HashSet</code>. HashSet is built into .NET and provides <code>O(1)</code> insertion, which you would think would be ideal for this use case. The downside to a <code>HashSet</code> is that its memory will be allocated on the heap. If you have to create a <code>HashSet</code> for every iteration of a hot loop, this can cause excess GC pressure.</p><p>Instead, what I use is a custom <code>BitSet</code>. <code>BitSet</code> is a struct that wraps an array of <code>uint64,</code> which acts as a bit array that I manually manage. The .NET runtime has a <code>BitArray</code> class, but it does not provide the API I need for my use cases. I need to iterate through all the set bits and call a function with the index of the set bit as an argument.</p><p>One of the advantages of the <code>BitSet</code> approach over <code>HashSet</code> is that the array used by the <code>BitSet</code> can be allocated from an <code>ArrayPool</code>, which means that <code>BitSet</code> will never increase GC pressure or take up room on the heap. The other is that it is faster than <code>HashSet</code> for iterating through the set bits using the <code>BitSet.iter</code> function.</p><p>Here is the definition of the <code>BitSet</code> type:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>BitSet</span><span class=o>&lt;[&lt;</span><span class=n>Measure</span><span class=o>&gt;]</span> <span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;(</span><span class=n>buckets</span><span class=o>:</span> <span class=kt>uint64</span><span class=bp>[]</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>new</span><span class=o>(</span><span class=n>capacity</span><span class=o>:</span> <span class=n>int</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>bucketsRequired</span> <span class=o>=</span> <span class=o>(</span><span class=n>capacity</span> <span class=o>+</span> <span class=n>63</span><span class=o>)</span> <span class=o>&gt;&gt;&gt;</span> <span class=n>6</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>buckets</span><span class=o>:</span> <span class=kt>uint64</span><span class=bp>[]</span> <span class=o>=</span> <span class=nn>Array</span><span class=p>.</span><span class=n>zeroCreate</span> <span class=n>bucketsRequired</span>
</span></span><span class=line><span class=cl>        <span class=n>BitSet</span><span class=o>&lt;_&gt;</span> <span class=n>buckets</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=sd>/// WARNING: Public for inlining
</span></span></span><span class=line><span class=cl><span class=sd></span>    <span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>_buckets</span> <span class=o>=</span> <span class=n>buckets</span>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>Capacity</span> <span class=o>=</span> <span class=n>buckets</span><span class=o>.</span><span class=n>Length</span> <span class=o>*</span> <span class=n>64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>Count</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>mutable</span> <span class=n>total</span> <span class=o>=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>bucket</span> <span class=k>in</span> <span class=n>b</span><span class=o>._</span><span class=n>buckets</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>            <span class=n>total</span> <span class=o>&lt;-</span> <span class=n>total</span> <span class=o>+</span> <span class=nn>System</span><span class=p>.</span><span class=nn>Numerics</span><span class=p>.</span><span class=nn>BitOperations</span><span class=p>.</span><span class=n>PopCount</span> <span class=n>bucket</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>total</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>Item</span>
</span></span><span class=line><span class=cl>        <span class=k>with</span> <span class=n>get</span> <span class=o>(</span><span class=n>itemKey</span><span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>bucketId</span><span class=o>,</span> <span class=n>mask</span> <span class=o>=</span> <span class=nn>Helpers</span><span class=p>.</span><span class=n>computeBucketAndMask</span> <span class=n>itemKey</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>buckets</span> <span class=o>=</span> <span class=n>b</span><span class=o>._</span><span class=n>buckets</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>bucket</span> <span class=o>=</span> <span class=n>buckets</span><span class=o>[</span><span class=n>bucketId</span><span class=o>]</span>
</span></span><span class=line><span class=cl>            <span class=o>(</span><span class=n>bucket</span> <span class=o>&amp;&amp;&amp;</span> <span class=n>mask</span><span class=o>)</span> <span class=o>&lt;&gt;</span> <span class=n>0UL</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>Contains</span><span class=o>(</span><span class=n>itemKey</span><span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>bucketId</span><span class=o>,</span> <span class=n>mask</span> <span class=o>=</span> <span class=nn>Helpers</span><span class=p>.</span><span class=n>computeBucketAndMask</span> <span class=n>itemKey</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>buckets</span> <span class=o>=</span> <span class=n>b</span><span class=o>._</span><span class=n>buckets</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>bucket</span> <span class=o>=</span> <span class=n>buckets</span><span class=o>[</span><span class=n>bucketId</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=o>(</span><span class=n>bucket</span> <span class=o>&amp;&amp;&amp;</span> <span class=n>mask</span><span class=o>)</span> <span class=o>&lt;&gt;</span> <span class=n>0UL</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>Add</span><span class=o>(</span><span class=n>itemKey</span><span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>bucketId</span><span class=o>,</span> <span class=n>mask</span> <span class=o>=</span> <span class=nn>Helpers</span><span class=p>.</span><span class=n>computeBucketAndMask</span> <span class=n>itemKey</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>bucket</span> <span class=o>=</span> <span class=n>buckets</span><span class=o>[</span><span class=n>bucketId</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=n>buckets</span><span class=o>[</span><span class=n>bucketId</span><span class=o>]</span> <span class=o>&lt;-</span> <span class=n>bucket</span> <span class=o>|||</span> <span class=n>mask</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>Remove</span><span class=o>(</span><span class=n>itemKey</span><span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>bucketId</span><span class=o>,</span> <span class=n>mask</span> <span class=o>=</span> <span class=nn>Helpers</span><span class=p>.</span><span class=n>computeBucketAndMask</span> <span class=n>itemKey</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>buckets</span> <span class=o>=</span> <span class=n>b</span><span class=o>._</span><span class=n>buckets</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>bucket</span> <span class=o>=</span> <span class=n>buckets</span><span class=o>[</span><span class=n>bucketId</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=n>buckets</span><span class=o>[</span><span class=n>bucketId</span><span class=o>]</span> <span class=o>&lt;-</span> <span class=n>bucket</span> <span class=o>&amp;&amp;&amp;</span> <span class=o>~~~</span><span class=n>mask</span>
</span></span></code></pre></td></tr></table></div></div><p>We also have a <code>BitSet</code> module where we define the functions for operating on <code>BitSet</code>. Here I show just the <code>iter</code> function. <code>iter</code> loops through each set bit in the array and calls the lambda <code>f</code> with the index of the set bit as the argument.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>module</span> <span class=nn>BitSet</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>inline</span> <span class=n>iter</span> <span class=o>([&lt;</span><span class=n>InlineIfLambda</span><span class=o>&gt;]</span> <span class=n>f</span><span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;</span> <span class=o>-&gt;</span> <span class=kt>unit</span><span class=o>)</span> <span class=o>(</span><span class=n>b</span><span class=o>:</span> <span class=n>BitSet</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>mutable</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// Source of algorithm: https://lemire.me/blog/2018/02/21/iterating-over-set-bits-quickly/
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>while</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>b</span><span class=o>._</span><span class=n>buckets</span><span class=o>.</span><span class=n>Length</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>mutable</span> <span class=n>bitSet</span> <span class=o>=</span> <span class=n>b</span><span class=o>._</span><span class=n>buckets</span><span class=o>[</span><span class=n>i</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>bitSet</span> <span class=o>&lt;&gt;</span> <span class=n>0UL</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>                <span class=k>let</span> <span class=nv>r</span> <span class=o>=</span> <span class=nn>System</span><span class=p>.</span><span class=nn>Numerics</span><span class=p>.</span><span class=nn>BitOperations</span><span class=p>.</span><span class=n>TrailingZeroCount</span> <span class=n>bitSet</span>
</span></span><span class=line><span class=cl>                <span class=k>let</span> <span class=nv>itemId</span> <span class=o>=</span> <span class=o>(</span><span class=n>i</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>6</span><span class=o>)</span> <span class=o>+</span> <span class=n>r</span> <span class=o>|&gt;</span> <span class=nn>LanguagePrimitives</span><span class=p>.</span><span class=n>Int32WithMeasure</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=o>(</span><span class=n>f</span> <span class=n>itemId</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>                <span class=n>bitSet</span> <span class=o>&lt;-</span> <span class=n>bitSet</span> <span class=o>^^^</span> <span class=o>(</span><span class=n>1UL</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>r</span><span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=n>i</span> <span class=o>&lt;-</span> <span class=n>i</span> <span class=o>+</span> <span class=n>1</span>
</span></span></code></pre></td></tr></table></div></div><p>I set up a benchmark to compare the performance of <code>HashSet</code> and <code>BitSet</code>. I define a unit of measure, <code>Chicken</code>, which I will use as the entity type to annotate my <code>int</code> values. I add 10 <code>int&lt;Chicken></code> between the values of <code>0&lt;Chicken></code> and <code>99&lt;Chicken></code> to both of these collections. This range of values is a good representation of the use case that I am concerned with. I then write a benchmark for measuring the time to iterate through the values in both collections to see how long it takes for both collections. When I run the benchmark using <code>BenchmarkDotNet</code> I get the following result:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>|</span>           <span class=n>Method</span> <span class=o>|</span>      <span class=n>Mean</span> <span class=o>|</span>     <span class=n>Error</span> <span class=o>|</span>    <span class=n>StdDev</span> <span class=o>|</span>   <span class=n>Gen0</span> <span class=o>|</span> <span class=n>Allocated</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|-----------------</span> <span class=o>|----------:|----------:|----------:|-------:|----------:|</span>
</span></span><span class=line><span class=cl><span class=o>|</span>          <span class=n>HashSet</span> <span class=o>|</span> <span class=n>23</span><span class=o>.</span><span class=n>377</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>3017</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>2822</span> <span class=n>ns</span> <span class=o>|</span>      <span class=o>-</span> <span class=o>|</span>         <span class=o>-</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span>             <span class=n>Iter</span> <span class=o>|</span>  <span class=n>7</span><span class=o>.</span><span class=n>048</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>1168</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>1092</span> <span class=n>ns</span> <span class=o>|</span>      <span class=o>-</span> <span class=o>|</span>         <span class=o>-</span> <span class=o>|</span>
</span></span></code></pre></td></tr></table></div></div><p>We see that the <code>iter</code> function for <code>BitSet</code> is approximately 3x faster than <code>HashSet</code> for iterating through the values.</p><h2 id=the-problem>The Problem</h2><p>Now, you may be thinking that <code>BitSet</code> is great, but there is a downside to this approach. The <code>iter</code> function takes a lambda as one of its arguments. Whenever the <code>BitSet</code> encounters a set bit, it then calls the lambda with the index of the set bit. Lambdas are intrinsic to programming in F#, but they have limitations. One of those limitations is that they cannot capture <code>Span&lt;'T></code> or <code>ByRefLike</code> types. Most of the time, this is not a big deal. F# developers are not often known as hardcore performance programmers, so most F# developers will not run into this problem.</p><p>I, on the other hand, work with <code>Span&lt;'T></code> and <code>ByRefLike</code> types all the time. They can be incredibly powerful for increasing your program&rsquo;s performance and decreasing memory allocations. Now, a word of caution. You probably don&rsquo;t need this. You can lead a very happy life as an F# developer, and never worry about this. This limitation only becomes an issue when you are trying to eke out every bit of performance you can, and you are likely not in that scenario. I happen to be in an odd situation because I work for a company with an F# dev team, and I&rsquo;m tasked with writing libraries for others to use that must be fast. For strategic reasons, we constrain ourselves to F#, so calling out to C/C++/Rust is not an option. You will appreciate what we cover next if you find yourself in a similar situation.</p><p>I have asked about relaxing some of the compiler restrictions around lambdas and capturing <code>Span&lt;'T></code>, but the effort would be large. The more I dug into how the F# compiler and the CLR interact, my appreciation for the complexity of the problem grows. This is also not the most important feature for the growth of F#, so I&rsquo;m not going to push for it. I hope to get good enough to contribute it to the F# compiler someday 😊.</p><h2 id=the-solution>The Solution</h2><p>So how do we get around this limitation? <code>BitSet</code> is intended for these hot loops where we likely want to be able to use some stack-allocated memory. This means we must be able to work with <code>BitSet</code> and <code>Span&lt;'T></code> simultaneously. The simple solution is to expose a new way of iterating through the set bits in the <code>BitSet</code>. We can implement <code>IEnumerable&lt;'T></code> for <code>BitSet</code> and use a <code>for...in...do</code> loop.</p><p>The easiest way to implement <code>IEnumerable&lt;'T></code> for <code>BitSet</code> is to define a <code>BitSetEnumerator</code>, which takes the logic used in the <code>iter</code> function but exposes it in a way that the <code>IEnumerable&lt;'T></code> interface expects. Let&rsquo;s see what that looks like:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>type</span> <span class=nc>BitSetEnumerator</span><span class=o>&lt;[&lt;</span><span class=n>Measure</span><span class=o>&gt;]</span> <span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;(</span><span class=n>buckets</span><span class=o>:</span> <span class=kt>uint64</span><span class=bp>[]</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>mutable</span> <span class=n>bucketIdx</span> <span class=o>=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>mutable</span> <span class=n>curBucket</span> <span class=o>=</span> <span class=n>0UL</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>mutable</span> <span class=n>curItem</span> <span class=o>=</span> <span class=nn>LanguagePrimitives</span><span class=p>.</span><span class=n>Int32WithMeasure</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;</span> <span class=o>-</span><span class=n>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>Current</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>curItem</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>&lt;_&gt;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=n>raise</span> <span class=o>(</span><span class=n>InvalidOperationException</span> <span class=s>&#34;Enumeration has not started. Call MoveNext.&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>curItem</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>MoveNext</span><span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Check if we have actually started iteration
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=n>curItem</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>&lt;_&gt;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=n>curBucket</span> <span class=o>&lt;-</span> <span class=n>buckets</span><span class=o>[</span><span class=n>bucketIdx</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// There are still items in the Current bucket we should return
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=n>curBucket</span> <span class=o>&lt;&gt;</span> <span class=n>0UL</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>r</span> <span class=o>=</span> <span class=nn>System</span><span class=p>.</span><span class=nn>Numerics</span><span class=p>.</span><span class=nn>BitOperations</span><span class=p>.</span><span class=n>TrailingZeroCount</span> <span class=n>curBucket</span>
</span></span><span class=line><span class=cl>            <span class=n>curItem</span> <span class=o>&lt;-</span> <span class=nn>LanguagePrimitives</span><span class=p>.</span><span class=n>Int32WithMeasure</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;((</span><span class=n>bucketIdx</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>6</span><span class=o>)</span> <span class=o>+</span> <span class=n>r</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>curBucket</span> <span class=o>&lt;-</span> <span class=n>curBucket</span> <span class=o>^^^</span> <span class=o>(</span><span class=n>1UL</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>r</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// We need to move to the next bucket of items
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>bucketIdx</span> <span class=o>&lt;-</span> <span class=n>bucketIdx</span> <span class=o>+</span> <span class=n>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>bucketIdx</span> <span class=o>&lt;</span> <span class=n>buckets</span><span class=o>.</span><span class=n>Length</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>                <span class=n>curBucket</span> <span class=o>&lt;-</span> <span class=n>buckets</span><span class=o>[</span><span class=n>bucketIdx</span><span class=o>]</span>
</span></span><span class=line><span class=cl>                <span class=n>b</span><span class=o>.</span><span class=n>MoveNext</span><span class=bp>()</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=k>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>Reset</span><span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>bucketIdx</span> <span class=o>&lt;-</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>        <span class=n>curBucket</span> <span class=o>&lt;-</span> <span class=n>0UL</span>
</span></span><span class=line><span class=cl>        <span class=n>curItem</span> <span class=o>&lt;-</span> <span class=nn>LanguagePrimitives</span><span class=p>.</span><span class=n>Int32WithMeasure</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;</span> <span class=o>-</span><span class=n>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>interface</span> <span class=n>IEnumerator</span><span class=o>&lt;</span><span class=n>int</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;&gt;</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>        <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>Current</span> <span class=o>=</span> <span class=n>b</span><span class=o>.</span><span class=n>Current</span> <span class=o>:&gt;</span> <span class=n>Object</span>
</span></span><span class=line><span class=cl>        <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>Current</span> <span class=o>=</span> <span class=n>b</span><span class=o>.</span><span class=n>Current</span>
</span></span><span class=line><span class=cl>        <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>MoveNext</span><span class=bp>()</span> <span class=o>=</span> <span class=n>b</span><span class=o>.</span><span class=n>MoveNext</span><span class=bp>()</span>
</span></span><span class=line><span class=cl>        <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>Reset</span><span class=bp>()</span> <span class=o>=</span> <span class=n>b</span><span class=o>.</span><span class=n>Reset</span><span class=bp>()</span>
</span></span><span class=line><span class=cl>        <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>Dispose</span><span class=bp>()</span> <span class=o>=</span> <span class=bp>()</span>
</span></span></code></pre></td></tr></table></div></div><p>The <code>BitSetEnumerator</code> type defines three methods for fulfilling the <code>IEnumerable&lt;'T></code> contract: <code>Current</code>, <code>MoveNext</code>, and <code>Reset</code>. You can see how the <code>BitSetEnumerator</code> fulfills the <code>IEnumerable&lt;'T></code> interface at the bottom. The type uses the same bit-shifting logic <code>iter</code> uses but breaks it up to support the methods that <code>IEnumerable&lt;'T></code> expects.</p><p>We can then have the <code>BitSet</code> collection implement the <code>IEnumerable&lt;'T></code> interface by returning an instance of the <code>BitSetEnumerator</code> when calling the <code>GetEnumerator</code> method.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>open</span> <span class=nn>System.Collections.Generic</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>BitSet</span><span class=o>&lt;[&lt;</span><span class=n>Measure</span><span class=o>&gt;]</span> <span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;(</span><span class=n>buckets</span><span class=o>:</span> <span class=kt>uint64</span><span class=bp>[]</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Previous logic here
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>interface</span> <span class=nn>System</span><span class=p>.</span><span class=nn>Collections</span><span class=p>.</span><span class=n>IEnumerable</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>        <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>GetEnumerator</span><span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>            <span class=o>(</span><span class=k>new</span> <span class=n>BitSetEnumerator</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;(</span><span class=n>buckets</span><span class=o>))</span> <span class=o>:&gt;</span> <span class=nn>System</span><span class=p>.</span><span class=nn>Collections</span><span class=p>.</span><span class=n>IEnumerator</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>interface</span> <span class=n>IEnumerable</span><span class=o>&lt;</span><span class=n>int</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;&gt;</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>        <span class=k>member</span> <span class=n>s</span><span class=p>.</span><span class=nf>GetEnumerator</span><span class=bp>()</span> <span class=o>=</span> <span class=k>new</span> <span class=n>BitSetEnumerator</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;(</span><span class=n>buckets</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>When we add this approach to the benchmarks, we get the following result:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>|</span>     <span class=n>Method</span> <span class=o>|</span>      <span class=n>Mean</span> <span class=o>|</span>     <span class=n>Error</span> <span class=o>|</span>    <span class=n>StdDev</span> <span class=o>|</span>   <span class=n>Gen0</span> <span class=o>|</span> <span class=n>Allocated</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|-----------</span> <span class=o>|----------:|----------:|----------:|-------:|----------:|</span>
</span></span><span class=line><span class=cl><span class=o>|</span>    <span class=n>HashSet</span> <span class=o>|</span> <span class=n>23</span><span class=o>.</span><span class=n>347</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>4024</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>3764</span> <span class=n>ns</span> <span class=o>|</span>      <span class=o>-</span> <span class=o>|</span>         <span class=o>-</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span>       <span class=n>Iter</span> <span class=o>|</span>  <span class=n>7</span><span class=o>.</span><span class=n>087</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>1000</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>0935</span> <span class=n>ns</span> <span class=o>|</span>      <span class=o>-</span> <span class=o>|</span>         <span class=o>-</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=n>Enumerable</span> <span class=o>|</span> <span class=n>55</span><span class=o>.</span><span class=n>521</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>9228</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>8181</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>0048</span> <span class=o>|</span>      <span class=n>40</span> <span class=n>B</span> <span class=o>|</span>
</span></span></code></pre></td></tr></table></div></div><p>The <code>IEnumerable&lt;'T></code> approach is twice as slow as using a <code>HashSet</code>. This is less than ideal. It is also allocating on the heap. This is because the interface necessitates the creation of an object on the heap. We&rsquo;ve negated most, if not all, of the benefits we hope to get from <code>BitSet</code>. What can we do?</p><h2 id=ducks-all-the-way-down>Ducks All The Way Down</h2><p>There&rsquo;s a feature of .NET that I don&rsquo;t hear about much but is important in this scenario. The .NET runtime will use duck-typing to implement C# <code>foreach</code> loops and their equivalents. The runtime will look at the type and see if it has a <code>GetEnumerator</code> method that returns a type with the <code>Current</code> field and the <code>MoveNext</code> method. Well, the <code>for...in...do</code> loop in F# is the equivalent to the C# <code>foreach</code> loop.</p><p>What if instead of implementing <code>IEnumerable&lt;'T></code> we rely on the .NET duck-typing approach? We can change our enumerator to be a <code>struct</code> so that it doesn&rsquo;t allocate any memory on the heap, and we&rsquo;ll avoid the overhead of an interface.</p><p>Here&rsquo;s what the <code>BitSetEnumerator</code> looks like as a struct with only the necessary pieces for duck-typing.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>BitSetEnumerator</span><span class=o>&lt;[&lt;</span><span class=n>Measure</span><span class=o>&gt;]</span> <span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=k>mutable</span> <span class=n>BucketIdx</span><span class=o>:</span> <span class=n>int</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=k>mutable</span> <span class=n>CurBucket</span><span class=o>:</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=k>mutable</span> <span class=n>CurItem</span><span class=o>:</span> <span class=n>int</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=k>val</span> <span class=n>Buckets</span><span class=o>:</span> <span class=kt>uint64</span><span class=bp>[]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>new</span><span class=o>(</span><span class=n>buckets</span><span class=o>:</span> <span class=kt>uint64</span><span class=bp>[]</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=o>{</span>
</span></span><span class=line><span class=cl>            <span class=n>BucketIdx</span> <span class=o>=</span> <span class=n>0</span>
</span></span><span class=line><span class=cl>            <span class=n>CurBucket</span> <span class=o>=</span> <span class=n>0UL</span>
</span></span><span class=line><span class=cl>            <span class=n>CurItem</span> <span class=o>=</span> <span class=nn>LanguagePrimitives</span><span class=p>.</span><span class=n>Int32WithMeasure</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;</span> <span class=o>-</span><span class=n>1</span>
</span></span><span class=line><span class=cl>            <span class=n>Buckets</span> <span class=o>=</span> <span class=n>buckets</span>
</span></span><span class=line><span class=cl>        <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>Current</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>b</span><span class=o>.</span><span class=n>CurItem</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>&lt;_&gt;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=n>raise</span> <span class=o>(</span><span class=n>InvalidOperationException</span> <span class=s>&#34;Enumeration has not started. Call MoveNext.&#34;</span><span class=o>)</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=o>.</span><span class=n>CurItem</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>MoveNext</span><span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Check if we have actually started iteration
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=n>b</span><span class=o>.</span><span class=n>CurItem</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>&lt;_&gt;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>&lt;-</span> <span class=n>b</span><span class=o>.</span><span class=n>Buckets</span><span class=o>[</span><span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// There are still items in the Current bucket we should return
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>&lt;&gt;</span> <span class=n>0UL</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>r</span> <span class=o>=</span> <span class=nn>System</span><span class=p>.</span><span class=nn>Numerics</span><span class=p>.</span><span class=nn>BitOperations</span><span class=p>.</span><span class=n>TrailingZeroCount</span> <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=o>.</span><span class=n>CurItem</span> <span class=o>&lt;-</span> <span class=nn>LanguagePrimitives</span><span class=p>.</span><span class=n>Int32WithMeasure</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;((</span><span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>6</span><span class=o>)</span> <span class=o>+</span> <span class=n>r</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>&lt;-</span> <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>^^^</span> <span class=o>(</span><span class=n>1UL</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>r</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// We need to move to the next bucket of items
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span> <span class=o>&lt;-</span> <span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span> <span class=o>+</span> <span class=n>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span> <span class=o>&lt;</span> <span class=n>b</span><span class=o>.</span><span class=n>Buckets</span><span class=o>.</span><span class=n>Length</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>                <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>&lt;-</span> <span class=n>b</span><span class=o>.</span><span class=n>Buckets</span><span class=o>[</span><span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span><span class=o>]</span>
</span></span><span class=line><span class=cl>                <span class=n>b</span><span class=o>.</span><span class=n>MoveNext</span><span class=bp>()</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=k>false</span>
</span></span></code></pre></td></tr></table></div></div><p>Things look a bit different since <code>BitSetEnumerator</code> is now a struct and therefore requires different approaches to handling the internal data.</p><p>We also change the <code>BitSet</code> type to only have a <code>GetEnumerator()</code> method instead of implementing <code>IEnumerable&lt;'T></code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>BitSet</span><span class=o>&lt;[&lt;</span><span class=n>Measure</span><span class=o>&gt;]</span> <span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;(</span><span class=n>buckets</span><span class=o>:</span> <span class=kt>uint64</span><span class=bp>[]</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=c1>// Previous logic
</span></span></span><span class=line><span class=cl><span class=c1></span>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>b</span><span class=p>.</span><span class=nf>GetEnumerator</span><span class=bp>()</span> <span class=o>=</span> <span class=n>BitSetEnumerator</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;(</span><span class=n>buckets</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>When we benchmark this approach, we get the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>|     Method |      Mean |     Error |    StdDev |   Gen0 | Allocated |
</span></span><span class=line><span class=cl>|----------- |----------:|----------:|----------:|-------:|----------:|
</span></span><span class=line><span class=cl>|    HashSet | 23.347 ns | 0.4024 ns | 0.3764 ns |      - |         - |
</span></span><span class=line><span class=cl>|       Iter |  7.087 ns | 0.1000 ns | 0.0935 ns |      - |         - |
</span></span><span class=line><span class=cl>| Enumerable | 55.521 ns | 0.9228 ns | 0.8181 ns | 0.0048 |      40 B |
</span></span><span class=line><span class=cl>| DuckTyping | 28.039 ns | 0.5183 ns | 0.4848 ns |      - |         - |
</span></span></code></pre></td></tr></table></div></div><p>This is much better. Our performance is almost that of a <code>HashSet</code>. Something to be aware of, the duck-typing approach and the <code>IEnumerable&lt;'T></code> are not mutually exclusive. If you implement both, the runtime will pick the faster approach in the testing I have done. In the production code, we include both because the <code>IEnumerable&lt;'T></code> is necessary for using the <code>BitSet</code> with the <code>Seq</code> module.</p><h2 id=inline-all-the-things-when-it-helps>Inline All The Things (When it helps)</h2><p>You have probably noticed that our loop-based approach&rsquo;s performance is still not near the <code>iter</code> method. That&rsquo;s to be expected. The for-loop approach adds overhead to the iteration. The F# compiler has some special transforms that it does for arrays which makes using a <code>for...in...do</code> loop over the elements of an array incredibly fast, but most other collections do not get that special treatment.</p><p>There is something we can do to get a little more performance, though. Right now, each time the <code>MoveNext</code> method is called, it creates a new stack frame. This adds overhead to the loop when it has to copy data for each instance of the stack frame. If we could inline the logic of the <code>MoveNext</code> method, we could reduce the number of stack frames created and potentially get a performance boost.</p><p>If you try to add the <code>inline</code> keyword to <code>Current</code> and <code>MoveNext</code> on <code>BitSetEnumerator</code>, you will have a problem. The compiler will give you an error that looks something like this:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>D:\Documents\GitHub\FSharpPerformance\BitSetEnumeration\DuckTyping.fs(55,17): error FS1114: The value &#39;BitSetEnumeration.DuckTyping.BitSetEnumerator.MoveNext&#39; was marked inline but was not bound in the optimi
</span></span><span class=line><span class=cl>zation environment [D:\Documents\GitHub\FSharpPerformance\BitSetEnumeration\BitSetEnumeration.fsproj]
</span></span><span class=line><span class=cl>D:\Documents\GitHub\FSharpPerformance\BitSetEnumeration\DuckTyping.fs(37,21): error FS1113: The value &#39;MoveNext&#39; was marked inline but its implementation makes use of an internal or private function which is
</span></span><span class=line><span class=cl>not sufficiently accessible [D:\Documents\GitHub\FSharpPerformance\BitSetEnumeration\BitSetEnumeration.fsproj]
</span></span><span class=line><span class=cl>D:\Documents\GitHub\FSharpPerformance\BitSetEnumeration\DuckTyping.fs(55,17): warning FS1116: A value marked as &#39;inline&#39; has an unexpected value [D:\Documents\GitHub\FSharpPerformance\BitSetEnumeration\BitSet
</span></span><span class=line><span class=cl>Enumeration.fsproj]
</span></span><span class=line><span class=cl>D:\Documents\GitHub\FSharpPerformance\BitSetEnumeration\DuckTyping.fs(55,17): error FS1118: Failed to inline the value &#39;MoveNext&#39; marked &#39;inline&#39;, perhaps because a recursive value was marked &#39;inline&#39; [D:\Doc
</span></span><span class=line><span class=cl>uments\GitHub\FSharpPerformance\BitSetEnumeration\BitSetEnumeration.fsproj]
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>The build failed. Fix the build errors and run again.
</span></span></code></pre></td></tr></table></div></div><p>That looks like a lot of garbage, but the important part is near the end. It reports an error on line 55 of our <code>DuckTyping.fs</code>, which mentions &ldquo;perhaps because a recursive value was marked <code>inline</code>.&rdquo; That&rsquo;s the clue we need. The <code>MoveNext</code> method is recursive at the moment, so the inlining logic of the F# compiler cannot work. What we need to do is remove this recursion. When we remove the recursion from the <code>MoveNext</code> method, we get the following:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl>    <span class=k>member</span> <span class=k>inline</span> <span class=n>b</span><span class=o>.</span><span class=n>MoveNext</span><span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Check if we have actually started iteration
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=n>b</span><span class=o>.</span><span class=n>CurItem</span> <span class=o>&lt;</span> <span class=n>0</span><span class=o>&lt;_&gt;</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>&lt;-</span> <span class=n>b</span><span class=o>.</span><span class=n>Buckets</span><span class=o>[</span><span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span><span class=o>]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// There are still items in the Current bucket we should return
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>if</span> <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>&lt;&gt;</span> <span class=n>0UL</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>r</span> <span class=o>=</span> <span class=nn>System</span><span class=p>.</span><span class=nn>Numerics</span><span class=p>.</span><span class=nn>BitOperations</span><span class=p>.</span><span class=n>TrailingZeroCount</span> <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=o>.</span><span class=n>CurItem</span> <span class=o>&lt;-</span> <span class=nn>LanguagePrimitives</span><span class=p>.</span><span class=n>Int32WithMeasure</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;((</span><span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>6</span><span class=o>)</span> <span class=o>+</span> <span class=n>r</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>&lt;-</span> <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>^^^</span> <span class=o>(</span><span class=n>1UL</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>r</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=c1>// We need to move to the next bucket of items
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span> <span class=o>&lt;-</span> <span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span> <span class=o>+</span> <span class=n>1</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>mutable</span> <span class=n>result</span> <span class=o>=</span> <span class=k>false</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=k>while</span> <span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span> <span class=o>&lt;</span> <span class=n>b</span><span class=o>.</span><span class=n>Buckets</span><span class=o>.</span><span class=n>Length</span> <span class=o>&amp;&amp;</span> <span class=o>(</span><span class=ow>not</span> <span class=n>result</span><span class=o>)</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>                <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>&lt;-</span> <span class=n>b</span><span class=o>.</span><span class=n>Buckets</span><span class=o>[</span><span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span><span class=o>]</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=c1>// There are still items in the Current bucket we should return
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>if</span> <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>&lt;&gt;</span> <span class=n>0UL</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>                    <span class=k>let</span> <span class=nv>r</span> <span class=o>=</span> <span class=nn>System</span><span class=p>.</span><span class=nn>Numerics</span><span class=p>.</span><span class=nn>BitOperations</span><span class=p>.</span><span class=n>TrailingZeroCount</span> <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span>
</span></span><span class=line><span class=cl>                    <span class=n>b</span><span class=o>.</span><span class=n>CurItem</span> <span class=o>&lt;-</span> <span class=nn>LanguagePrimitives</span><span class=p>.</span><span class=n>Int32WithMeasure</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>Measure</span><span class=o>&gt;((</span><span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>6</span><span class=o>)</span> <span class=o>+</span> <span class=n>r</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>&lt;-</span> <span class=n>b</span><span class=o>.</span><span class=n>CurBucket</span> <span class=o>^^^</span> <span class=o>(</span><span class=n>1UL</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>r</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                    <span class=n>result</span> <span class=o>&lt;-</span> <span class=k>true</span>
</span></span><span class=line><span class=cl>                
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=ow>not</span> <span class=n>result</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>                    <span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span> <span class=o>&lt;-</span> <span class=n>b</span><span class=o>.</span><span class=n>BucketIdx</span> <span class=o>+</span> <span class=n>1</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>            <span class=n>result</span>
</span></span></code></pre></td></tr></table></div></div><p>The logic for moving to the next bucket and checking for values has gotten more complex, but it no longer recurses. This allows us to use the <code>inline</code> keyword to get the F# compiler to inline this logic where it is used. This will reduce the number of stack frames used in our loop. Let&rsquo;s see what the performance of this version is:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>|</span>     <span class=n>Method</span> <span class=o>|</span>      <span class=n>Mean</span> <span class=o>|</span>     <span class=n>Error</span> <span class=o>|</span>    <span class=n>StdDev</span> <span class=o>|</span>   <span class=n>Gen0</span> <span class=o>|</span> <span class=n>Allocated</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|-----------</span> <span class=o>|----------:|----------:|----------:|-------:|----------:|</span>
</span></span><span class=line><span class=cl><span class=o>|</span>    <span class=n>HashSet</span> <span class=o>|</span> <span class=n>23</span><span class=o>.</span><span class=n>347</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>4024</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>3764</span> <span class=n>ns</span> <span class=o>|</span>      <span class=o>-</span> <span class=o>|</span>         <span class=o>-</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span>       <span class=n>Iter</span> <span class=o>|</span>  <span class=n>7</span><span class=o>.</span><span class=n>087</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>1000</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>0935</span> <span class=n>ns</span> <span class=o>|</span>      <span class=o>-</span> <span class=o>|</span>         <span class=o>-</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=n>Enumerable</span> <span class=o>|</span> <span class=n>55</span><span class=o>.</span><span class=n>521</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>9228</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>8181</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>0048</span> <span class=o>|</span>      <span class=n>40</span> <span class=n>B</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span> <span class=n>DuckTyping</span> <span class=o>|</span> <span class=n>28</span><span class=o>.</span><span class=n>039</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>5183</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>4848</span> <span class=n>ns</span> <span class=o>|</span>      <span class=o>-</span> <span class=o>|</span>         <span class=o>-</span> <span class=o>|</span>
</span></span><span class=line><span class=cl><span class=o>|</span>   <span class=n>Inlining</span> <span class=o>|</span> <span class=n>13</span><span class=o>.</span><span class=n>315</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>2178</span> <span class=n>ns</span> <span class=o>|</span> <span class=n>0</span><span class=o>.</span><span class=n>2037</span> <span class=n>ns</span> <span class=o>|</span>      <span class=o>-</span> <span class=o>|</span>         <span class=o>-</span> <span class=o>|</span>
</span></span></code></pre></td></tr></table></div></div><p>Inlining is now faster than <code>HashSet</code> but still slower than <code>Iter</code>. This is a win for me because there&rsquo;s now no performance downside to <code>BitSet</code> compared to <code>HashSet</code> for this scenario. Would I like to be able to match the performance of <code>Iter</code>? Yes, absolutely, but this is already nowhere near the bottleneck of our engine, so I moved on to other problems.</p><h2 id=conclusion>Conclusion</h2><p>You&rsquo;ve learned a little about implementing <code>IEnumerable&lt;'T></code> for custom collections that you write and how to use the duck-typing of the <code>foreach</code> loop in .NET to get even better performance. We&rsquo;ve also shown that we can perform even better using the <code>inline</code> keyword to remove stack frames.</p><p>I recommend that you stick with the built-in looping functions provided by F#: <code>map</code>, <code>iter</code>, <code>iteri</code>, etc. They are highly optimized and will give you great performance out of the box. In rare cases, you should consider other options where the need to capture a <code>Span&lt;'T></code> or another restriction forces you to use other looping constructs. I hope you find this helpful. Please feel free to reach out with any questions or critiques 😊.</p></div><div id=comments></div></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.121.1">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2019 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=matthewcrews.com target=_blank>Matthew Crews</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"PASDMWALPK",algoliaIndex:"index.en",algoliaSearchKey:"b42948e51daaa93df92381c8e2ac0f93",highlightTag:"em",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>