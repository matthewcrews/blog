<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>Fast Tracking of Item Observations - Matthew Crews</title><meta name=Description content="Hugo theme - LoveIt"><meta property="og:title" content="Fast Tracking of Item Observations">
<meta property="og:description" content="I am writing a graph algorithm at the heart of one of the products we are developing at Simulation Dynamics. A part of the algorithm is tracking whether a node or vertex has been observed yet or not. As the algorithm progresses, it will mark whether it has completed processing a node or a vertex to know it does not need to continue through the graph.
This algorithm is part of the inner loop of the simulation and needs to be as fast as possible."><meta property="og:type" content="article"><meta property="og:url" content="https://matthewcrews.com/blog/2022/02/high-performance-observation-tracking/"><meta property="og:image" content="https://matthewcrews.com/logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-02-06T00:00:00+00:00"><meta property="article:modified_time" content="2023-12-17T00:23:58-08:00"><meta property="og:site_name" content="Matthew Crews"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://matthewcrews.com/logo.png"><meta name=twitter:title content="Fast Tracking of Item Observations"><meta name=twitter:description content="I am writing a graph algorithm at the heart of one of the products we are developing at Simulation Dynamics. A part of the algorithm is tracking whether a node or vertex has been observed yet or not. As the algorithm progresses, it will mark whether it has completed processing a node or a vertex to know it does not need to continue through the graph.
This algorithm is part of the inner loop of the simulation and needs to be as fast as possible."><meta name=twitter:site content="@xxxx"><meta name=application-name content="Mathew Crews"><meta name=apple-mobile-web-app-title content="Mathew Crews"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://matthewcrews.com/blog/2022/02/high-performance-observation-tracking/><link rel=prev href=https://matthewcrews.com/blog/2021/12/fsharp-loves-mutation/><link rel=next href=https://matthewcrews.com/blog/2022/03/performance-of-key-value-lookups-types/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"Fast Tracking of Item Observations","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/matthewcrews.com\/blog\/2022\/02\/high-performance-observation-tracking\/"},"image":[{"@type":"ImageObject","url":"https:\/\/matthewcrews.com\/images\/Apple-Devices-Preview.png","width":3200,"height":2048}],"genre":"blog","wordcount":2288,"url":"https:\/\/matthewcrews.com\/blog\/2022\/02\/high-performance-observation-tracking\/","datePublished":"2022-02-06T00:00:00+00:00","dateModified":"2023-12-17T00:23:58-08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/matthewcrews.com\/images\/fast_fsharp_avatar.png"},"author":{"@type":"Person","name":"Matthew Crews"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Matthew Crews">Matthew Crews</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/blog/>Blog </a><a class=menu-item href=/about/>About </a><a class=menu-item href=https://github.com/matthewcrews/blog title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Matthew Crews">Matthew Crews</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/blog/ title>Blog</a><a class=menu-item href=/about/ title>About</a><a class=menu-item href=https://github.com/matthewcrews/blog title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page single special"><h1 class="single-title animate__animated animate__pulse animate__faster">Fast Tracking of Item Observations</h1><div class=content id=content><p>I am writing a graph algorithm at the heart of one of the products we are developing at Simulation Dynamics. A part of the algorithm is tracking whether a node or vertex has been observed yet or not. As the algorithm progresses, it will mark whether it has completed processing a node or a vertex to know it does not need to continue through the graph.</p><p>This algorithm is part of the inner loop of the simulation and needs to be as fast as possible. Speed is a critical feature for us, so essentially, anything is allowed if it gives us more speed. The only requirement is it be written in .NET (preferably F#) and runs on a modern x86-64 processor.</p><p>These graphs are almost always small, say 20 nodes and 30 vertices. We are modeling manufacturing processes, and the types of facilities that we simulate can be simplified down to these small graphs. This means we don&rsquo;t necessarily need to handle <code>N</code> nodes and <code>M</code> vertices, and we need an algorithm that is as fast as possible for these small cases.</p><h1 id=the-f-set>The F# Set</h1><p>I love the F# <code>Set&lt;'T></code> collection. When I just need to process sets of value and perform comparisons between them, nothing beats the tried and true <code>Set&lt;'T></code>. For those curious, the F# <code>Set</code> and <code>Map</code> collections are backed by a variation on the AVL tree. We actually have <a href=https://twitter.com/buybackoff target=_blank rel="noopener noreffer">Victor Baybekov</a> to thank for some massive performance improvements he provided in <a href=https://github.com/dotnet/fsharp/pull/10188 target=_blank rel="noopener noreffer">this pull request</a>.</p><p>Before I test out various approaches, I create a baseline performance test. I will generate 1,000,000 different indexes in a range of <code>0</code> to <code>50</code>. For each of these indices, I will check whether it is in the <code>Set</code> or not. If it is not in the <code>Set</code>, I will add it. If it is in the <code>Set</code>, I will remove it. This will simulate the type of behavior that the graph algorithm uses while traversing the graph. I will also use the <code>BenchmarkDotNet</code> library to measure my performance.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>open</span> <span class=nn>System</span>
</span></span><span class=line><span class=cl><span class=k>open</span> <span class=nn>FSharp.NativeInterop</span>
</span></span><span class=line><span class=cl><span class=k>open</span> <span class=nn>BenchmarkDotNet.Attributes</span>
</span></span><span class=line><span class=cl><span class=k>open</span> <span class=nn>BenchmarkDotNet.Running</span>
</span></span><span class=line><span class=cl><span class=k>open</span> <span class=nn>BenchmarkDotNet.Diagnosers</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>MemoryDiagnoser</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>Benchmarks</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>testIndexCount</span> <span class=o>=</span> <span class=n>1_000_000</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>indexRange</span> <span class=o>=</span> <span class=n>50</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>rng</span> <span class=o>=</span> <span class=n>Random</span> <span class=n>123</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Generate a set of random indices to check
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>let</span> <span class=nv>testIndexes</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=o>[|</span> <span class=k>for</span> <span class=o>_</span> <span class=o>=</span> <span class=n>1</span> <span class=k>to</span> <span class=n>testIndexCount</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Note: Next is exclusive on the upper bound
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>rng</span><span class=o>.</span><span class=n>Next</span> <span class=o>(</span><span class=n>0</span><span class=o>,</span> <span class=n>indexRange</span><span class=o>)</span> 
</span></span><span class=line><span class=cl>        <span class=o>|]</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=o>[&lt;</span><span class=n>Benchmark</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl>    <span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>SetTracker</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>mutable</span> <span class=n>tracker</span> <span class=o>=</span> <span class=nn>Set</span><span class=p>.</span><span class=n>empty</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=k>for</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span> <span class=k>to</span> <span class=n>testIndexes</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=n>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>testIndex</span> <span class=o>=</span> <span class=n>testIndexes</span><span class=o>[</span><span class=n>i</span><span class=o>]</span>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=n>tracker</span><span class=o>.</span><span class=n>Contains</span> <span class=n>testIndex</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Real world we would do work here and then flip the case
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>tracker</span> <span class=o>&lt;-</span> <span class=n>tracker</span><span class=o>.</span><span class=n>Remove</span> <span class=n>testIndex</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=n>tracker</span> <span class=o>&lt;-</span> <span class=n>tracker</span><span class=o>.</span><span class=n>Add</span> <span class=n>testIndex</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>        <span class=n>tracker</span>
</span></span></code></pre></td></tr></table></div></div><p>When I run this benchmark, I get the following result.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>|     Method |       Mean |     Error |    StdDev |      Gen 0 |     Allocated |
</span></span><span class=line><span class=cl>|----------- |-----------:|----------:|----------:|-----------:|--------------:|
</span></span><span class=line><span class=cl>| SetTracker | 130.889 ms | 1.7642 ms | 1.4732 ms | 27000.0000 | 226,813,932 B |
</span></span></code></pre></td></tr></table></div></div><p>We now have a baseline to compare against.</p><h2 id=the-net-hashset>The .NET HashSet</h2><p>The first thing someone will likely point out is, &ldquo;Matthew, you are using an immutable collection that you are constantly updating and rebinding. Why not use a mutable collection?&rdquo; Great question! Let&rsquo;s reach for the next most obvious collection in .NET, the <code>HashSet</code>. <code>HashSet</code> is found in the <code>System.Collections.Generic</code> namespace. Instead of using a tree to keep track of items, it uses a hash table. This should give us constant-time lookup, insertion, and removal.</p><p>We add a new test to our <code>Benchmarks</code> class&mldr;</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Benchmark</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>HashSetTracker</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>mutable</span> <span class=n>tracker</span> <span class=o>=</span> <span class=nn>Collections</span><span class=p>.</span><span class=nn>Generic</span><span class=p>.</span><span class=n>HashSet</span> <span class=bp>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span> <span class=k>to</span> <span class=n>testIndexes</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=n>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>testIndex</span> <span class=o>=</span> <span class=n>testIndexes</span><span class=o>[</span><span class=n>i</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>tracker</span><span class=o>.</span><span class=n>Contains</span> <span class=n>testIndex</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Real world we would do work here and then flip the case
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>tracker</span><span class=o>.</span><span class=n>Remove</span> <span class=n>testIndex</span> <span class=o>|&gt;</span> <span class=n>ignore</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>tracker</span><span class=o>.</span><span class=n>Add</span> <span class=n>testIndex</span> <span class=o>|&gt;</span> <span class=n>ignore</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tracker</span>
</span></span></code></pre></td></tr></table></div></div><p>&mldr; and re-run our benchmarks.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>|         Method |       Mean |     Error |    StdDev |      Gen 0 |     Allocated |
</span></span><span class=line><span class=cl>|--------------- |-----------:|----------:|----------:|-----------:|--------------:|
</span></span><span class=line><span class=cl>|     SetTracker | 130.889 ms | 1.7642 ms | 1.4732 ms | 27000.0000 | 226,813,932 B |
</span></span><span class=line><span class=cl>| HashSetTracker |  14.368 ms | 0.0613 ms | 0.0544 ms |          - |       2,800 B |
</span></span></code></pre></td></tr></table></div></div><p>We see that the <code>HashSet</code> is giving us a performance boost over the F# <code>Set</code>. This is expected since we don&rsquo;t have to re-arrange a tree when we perform insertion and deletion. This is NOT to say that <code>Set</code> is inferior to <code>HashSet</code>; please don&rsquo;t consider that the takeaway. <code>Set</code> can do many things that <code>HashSet</code> cannot. It just happens in this instance, <code>HashSet</code> appears to be a better choice. Oh, but we aren&rsquo;t done yet&mldr;</p><h2 id=plain-old-arrays>Plain Old Arrays</h2><p>One of my favorite talks on the internet is one by <a href=https://youtu.be/WDIkqP4JbkE target=_blank rel="noopener noreffer">Scott Meyers</a>, where he talks about the criticality of understanding memory hierarchies when writing high-performance code. My favorite moment is when he quotes a developer who writes high-frequency trading algorithms. The developer says, &ldquo;I don&rsquo;t care how fancy your data structure is; an array will beat it.&rdquo;</p><p>I can map all nodes and vertices to <code>int</code> values ahead of time for my use case. This means that I could easily track whether I have visited a node or index by looking up a <code>bool</code> in an array using the value for the node or vertex as an index into the array. Let&rsquo;s try that and see what we get. I add a new benchmark to my <code>Benchmarks</code> class to see how this approach performs.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Benchmark</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>BoolArrayTracker</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>tracker</span> <span class=o>=</span> <span class=nn>Array</span><span class=p>.</span><span class=n>create</span> <span class=n>indexRange</span> <span class=k>false</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span> <span class=k>to</span> <span class=n>testIndexes</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=n>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>testIndex</span> <span class=o>=</span> <span class=n>testIndexes</span><span class=o>[</span><span class=n>i</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>tracker</span><span class=o>[</span><span class=n>testIndex</span><span class=o>]</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Real world we would do work here and then flip the case
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>tracker</span><span class=o>[</span><span class=n>testIndex</span><span class=o>]</span> <span class=o>&lt;-</span> <span class=k>false</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>tracker</span><span class=o>[</span><span class=n>testIndex</span><span class=o>]</span> <span class=o>&lt;-</span> <span class=k>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tracker</span>
</span></span></code></pre></td></tr></table></div></div><p>We can now see how using an <code>array&lt;bool></code> performs against a <code>Set</code> and <code>HashSet</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>|           Method |       Mean |     Error |    StdDev |      Gen 0 |     Allocated |
</span></span><span class=line><span class=cl>|----------------- |-----------:|----------:|----------:|-----------:|--------------:|
</span></span><span class=line><span class=cl>|       SetTracker | 130.889 ms | 1.7642 ms | 1.4732 ms | 27000.0000 | 226,813,932 B |
</span></span><span class=line><span class=cl>|   HashSetTracker |  14.368 ms | 0.0613 ms | 0.0544 ms |          - |       2,800 B |
</span></span><span class=line><span class=cl>| BoolArrayTracker |   5.017 ms | 0.0447 ms | 0.0418 ms |          - |          84 B |
</span></span></code></pre></td></tr></table></div></div><p>Alright, we see another speed boost. Using just an array, we&rsquo;ve cut out some cycles that the <code>HashSet</code> has to perform when it performs a lookup. Now we are just taking a pointer to the head of the array and offsetting it to perform the lookup. It&rsquo;s hard to get much faster than this&mldr; or is it?</p><h3 id=enter-data-oriented-design>Enter Data-Oriented Design</h3><p>I&rsquo;ve been on a quest to become a better developer, and my latest wanderings have brought me to the world of Data-Oriented Design. I love <a href=https://youtu.be/rX0ItVEVjHc target=_blank rel="noopener noreffer">Mike Acton&rsquo;s talk</a> at CPP Con, and I highly recommend it for anyone who hasn&rsquo;t seen it. He mentions that when he sees a <code>bool</code> in a <code>Struct</code> he almost always knows that something has gone wrong. The reason is that a <code>bool</code> only contains 1 bit of information, but it still takes up 8 bits of memory. This means that if you are moving many types back and forth in the cache which contains bools, you are wasting a large amount of memory bandwidth.</p><p>At the time I watched it, I thought, &ldquo;Okay, I see your point about wasting memory bandwidth, but what if you really do need to know whether something is true or not?&rdquo; That sat in the back of my mind for a while, and I didn&rsquo;t see a solution. The other day though, <a href=https://twitter.com/thinkb4coding target=_blank rel="noopener noreffer">Jérémie Chassaing</a> gave an excellent <a href=https://youtu.be/eVJ5b1lwMJ8 target=_blank rel="noopener noreffer">talk</a> on writing high-performance F# with no memory allocation. In it, he showed an elegant trick for storing two <code>int32</code> in a single <code>int64</code>. You can watch the bit <a href="https://www.youtube.com/watch?v=eVJ5b1lwMJ8&amp;t=4008s" target=_blank rel="noopener noreffer">here</a>. He holds one of the <code>int32</code> in the bottom 32-bits of the <code>int64</code> and the other <code>int32</code> value in the top 32-bits. That may seem silly, but it provides the compiler a unique optimization that it wouldn&rsquo;t have otherwise. It can store both of those <code>int32</code> in a single 64-bit register. This is the fastest form of memory in a CPU.</p><p>Now, who don&rsquo;t we take that same trick, and instead of storing 2 <code>int32</code> values in an <code>int64</code>, what about 64 bools in an <code>int64</code>? Each bit of the <code>int64</code> can correspond to a node or vertex in the graph. Instead of passing an <code>array&lt;bool></code> around, we can pass a single <code>int64</code>. Remember that for this use case, it is incredibly rare to see more than 20 nodes and 30 vertices, so 64-bits is plenty to store whether we have observed them or not.</p><p>Let&rsquo;s create a new type for wrapping our <code>int64</code> and provide some convenience methods for working with it. We will define it as a <code>Struct</code> since that provides the .NET compiler a large number of options for optimizing it.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>Int64Tracker</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>private</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>        <span class=k>mutable</span> <span class=n>Value</span> <span class=o>:</span> <span class=kt>int64</span>
</span></span><span class=line><span class=cl>    <span class=o>}</span>
</span></span><span class=line><span class=cl>    <span class=k>static</span> <span class=k>member</span> <span class=n>Create</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=o>{</span> <span class=n>Value</span> <span class=o>=</span> <span class=n>0L</span> <span class=o>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Check whether a position has been set to 1 or not
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>member</span> <span class=n>this</span><span class=p>.</span><span class=nf>IsSet</span> <span class=o>(</span><span class=n>position</span><span class=o>:</span> <span class=n>int</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=o>(</span><span class=n>this</span><span class=o>.</span><span class=n>Value</span> <span class=o>&amp;&amp;&amp;</span> <span class=o>(</span><span class=n>1L</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>position</span><span class=o>))</span> <span class=o>&lt;&gt;</span> <span class=n>0L</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Sets a bit at a position to 1
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>member</span> <span class=n>this</span><span class=p>.</span><span class=nf>Set</span> <span class=o>(</span><span class=n>position</span><span class=o>:</span> <span class=n>int</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>this</span><span class=o>.</span><span class=n>Value</span> <span class=o>&lt;-</span> <span class=o>(</span><span class=n>1L</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>position</span><span class=o>)</span> <span class=o>|||</span> <span class=n>this</span><span class=o>.</span><span class=n>Value</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=c1>// Sets a bit at a position to 0
</span></span></span><span class=line><span class=cl><span class=c1></span>    <span class=k>member</span> <span class=n>this</span><span class=p>.</span><span class=nf>UnSet</span> <span class=o>(</span><span class=n>position</span><span class=o>:</span> <span class=n>int</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>        <span class=n>this</span><span class=o>.</span><span class=n>Value</span> <span class=o>&lt;-</span> <span class=o>~~~</span> <span class=o>(</span><span class=n>1</span> <span class=o>&lt;&lt;&lt;</span> <span class=n>position</span><span class=o>)</span> <span class=o>&amp;&amp;&amp;</span> <span class=n>this</span><span class=o>.</span><span class=n>Value</span>
</span></span></code></pre></td></tr></table></div></div><p>Let&rsquo;s unpack this. The <code>Value</code> field is used to track whether something has been observed or not. The <code>Create</code> method gives us a new <code>Int64Tracker</code> where all the bits are set to <code>0</code>. The <code>IsSet</code> method takes a position and checks whether that position is 0 or not. It does this by taking a value of <code>1L</code>, which puts a value of 1 in the bottom bit and then left, shifting it to the desired position. It then does a bitwise <code>AND</code> between the <code>Value</code> and the bit-shifted value. This will return 0s for every location except for possibly the position we are interested in. If there is a 1 in the desired position, it will <code>AND</code> with our shifted 1 and return a non-zero number. If there is a <code>0</code> in the position of interest, all the bits will return <code>0</code>, and the resulting value will be equal to <code>0</code>.</p><p>The <code>Set</code> method takes a position and sets the bit in that position to <code>1</code>. It does this by taking a value of <code>1L</code>, which has a <code>1</code> in the bottom bit, left-shifts it to the desired position, and then performs a bitwise <code>OR</code> with <code>Value</code>. If the value in the given position was already <code>1</code>, it will still be a <code>1</code>. If it was <code>0</code>, it will be changed to <code>1</code>. Here&rsquo;s a <a href="https://youtu.be/ZRNO-ewsNcQ?t=64" target=_blank rel="noopener noreffer">quick video</a> showing the operation.</p><p>The final method, <code>UnSet</code>, takes <code>1L</code> and left-shifts it to the desired position. It then does a bitwise negation. This means that all the bits will be <code>1</code> except for the position that we want to turn into a <code>0</code>. We then <code>AND</code> that mask with <code>Value</code> to get our updated <code>Value</code>. Here&rsquo;s a <a href="https://youtu.be/ZRNO-ewsNcQ?t=113" target=_blank rel="noopener noreffer">video</a> showing how this is done.</p><p>We now have a new type that allows us to track up to 64 different items, which is enough for our use case. Let&rsquo;s add a benchmark.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Benchmark</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>Int64Tracker</span> <span class=bp>()</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>mutable</span> <span class=n>tracker</span> <span class=o>=</span> <span class=nn>Int64Tracker</span><span class=p>.</span><span class=n>Init</span> <span class=bp>()</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>i</span> <span class=o>=</span> <span class=n>0</span> <span class=k>to</span> <span class=n>testIndexes</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=n>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>        <span class=k>let</span> <span class=nv>testIndex</span> <span class=o>=</span> <span class=n>testIndexes</span><span class=o>[</span><span class=n>i</span><span class=o>]</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>tracker</span><span class=o>.</span><span class=n>IsSet</span> <span class=n>testIndex</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>            <span class=c1>// Real world we would do work here and then flip the case
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=n>tracker</span><span class=o>.</span><span class=n>UnSet</span> <span class=n>testIndex</span>
</span></span><span class=line><span class=cl>        <span class=k>else</span>
</span></span><span class=line><span class=cl>            <span class=n>tracker</span><span class=o>.</span><span class=n>Set</span> <span class=n>testIndex</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=n>tracker</span>
</span></span></code></pre></td></tr></table></div></div><p>And we run our benchmarks to see how fast we are now.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>|           Method |       Mean |     Error |    StdDev |      Gen 0 |     Allocated |
</span></span><span class=line><span class=cl>|----------------- |-----------:|----------:|----------:|-----------:|--------------:|
</span></span><span class=line><span class=cl>|       SetTracker | 130.889 ms | 1.7642 ms | 1.4732 ms | 27000.0000 | 226,813,932 B |
</span></span><span class=line><span class=cl>|   HashSetTracker |  14.368 ms | 0.0613 ms | 0.0544 ms |          - |       2,800 B |
</span></span><span class=line><span class=cl>| BoolArrayTracker |   5.017 ms | 0.0447 ms | 0.0418 ms |          - |          84 B |
</span></span><span class=line><span class=cl>|     Int64Tracker |   3.979 ms | 0.0097 ms | 0.0081 ms |          - |           4 B |
</span></span></code></pre></td></tr></table></div></div><p>Excellent! We&rsquo;ve shaved off another 20%. This may not seem like much but let me note something important. The <code>BoolArrayTracker</code> takes an entire cache-line to store the information for 64 items. <code>Int64Tracker</code> only uses 4 bytes out of the 64 that are available. This means that in the full algorithm, we can use the remaining 60 bytes to track other information and ensure all of that information is on the same cache-line. This may seem silly at the moment but can have a significant impact on overall performance if we experience cache eviction in the middle of our tightest loop. More to come!</p><p>If you have critiques or thoughts on how to improve, I&rsquo;d love to hear it. All the code can be found <a href=https://github.com/matthewcrews/BitFieldTracking target=_blank rel="noopener noreffer">here</a>. Feel free to make suggestions or pull requests.</p><p>If you liked this post and want to hear more about writing high-performance F# and Mathematical Programming, please subscribe to my list!</p><script>window.mootrack||!function(e,t,n,s,o){function i(e){var s,o=~~(Date.now()/3e5),t=document.createElement(n);t.async=!0,t.src=e+"?ts="+o,s=document.getElementsByTagName(n)[0],s.parentNode.insertBefore(t,s)}e.MooTrackerObject=o,e[o]=e[o]||function(){return e[o].q?void e[o].q.push(arguments):void(e[o].q=[arguments])},window.attachEvent?window.attachEvent("onload",i.bind(this,s)):window.addEventListener("load",i.bind(this,s),!1)}(window,document,"script","https://cdn.stat-track.com/statics/moosend-tracking.min.js","mootrack"),mootrack("loadForm","b498d29aaba84b5bb3e0479003dc7264")</script><div data-mooform-id=b498d29a-aba8-4b5b-b3e0-479003dc7264></div></div><div id=comments></div></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.121.1">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2019 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=matthewcrews.com target=_blank>Matthew Crews</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"PASDMWALPK",algoliaIndex:"index.en",algoliaSearchKey:"b42948e51daaa93df92381c8e2ac0f93",highlightTag:"em",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>