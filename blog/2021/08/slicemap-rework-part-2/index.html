<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>SliceMap Rework - Part 2 - Matthew Crews</title><meta name=Description content="Hugo theme - LoveIt"><meta property="og:title" content="SliceMap Rework - Part 2"><meta property="og:description" content="Welcome to part 2 of this series. In the previous post we setup our problem which is to speed up the SliceMap family of types for sparse data. We created benchmarks and measured the performance of the current implementation. I gave a brief overview of a new approach I had come up with and showed how it failed miserably.
We were in a depressing place at the end of the last post but hope burns eternal!"><meta property="og:type" content="article"><meta property="og:url" content="https://matthewcrews.com/blog/2021/08/slicemap-rework-part-2/"><meta property="og:image" content="https://matthewcrews.com/logo.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2021-08-23T00:00:00+00:00"><meta property="article:modified_time" content="2023-05-05T00:01:17-07:00"><meta property="og:site_name" content="Matthew Crews"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://matthewcrews.com/logo.png"><meta name=twitter:title content="SliceMap Rework - Part 2"><meta name=twitter:description content="Welcome to part 2 of this series. In the previous post we setup our problem which is to speed up the SliceMap family of types for sparse data. We created benchmarks and measured the performance of the current implementation. I gave a brief overview of a new approach I had come up with and showed how it failed miserably.
We were in a depressing place at the end of the last post but hope burns eternal!"><meta name=application-name content="Mathew Crews"><meta name=apple-mobile-web-app-title content="Mathew Crews"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://matthewcrews.com/blog/2021/08/slicemap-rework-part-2/><link rel=prev href=https://matthewcrews.com/blog/2021/08/slicemap-rework-part-1/><link rel=next href=https://matthewcrews.com/blog/2021/11/records-as-keys-for-dictionaries/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"SliceMap Rework - Part 2","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/matthewcrews.com\/blog\/2021\/08\/slicemap-rework-part-2\/"},"image":[{"@type":"ImageObject","url":"https:\/\/matthewcrews.com\/images\/Apple-Devices-Preview.png","width":3200,"height":2048}],"genre":"blog","wordcount":1708,"url":"https:\/\/matthewcrews.com\/blog\/2021\/08\/slicemap-rework-part-2\/","datePublished":"2021-08-23T00:00:00+00:00","dateModified":"2023-05-05T00:01:17-07:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/matthewcrews.com\/images\/fast_fsharp_avatar.png"},"author":{"@type":"Person","name":"Matthew Crews"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Matthew Crews">Matthew Crews</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/blog/>Blog </a><a class=menu-item href=/about/>About </a><a class=menu-item href=https://github.com/matthewcrews/blog title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Matthew Crews">Matthew Crews</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/blog/ title>Blog</a><a class=menu-item href=/about/ title>About</a><a class=menu-item href=https://github.com/matthewcrews/blog title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page single special"><h1 class="single-title animate__animated animate__pulse animate__faster">SliceMap Rework - Part 2</h1><div class=content id=content><p>Welcome to part 2 of this series. In the <a href=/blog/2021/08/slicemap-rework-part-1/ rel>previous post</a> we setup our problem which is to speed up the <code>SliceMap</code> family of types for sparse data. We created benchmarks and measured the performance of the current implementation. I gave a brief overview of a new approach I had come up with and showed how it failed miserably.</p><p>We were in a depressing place at the end of the last post but hope burns eternal! I have already been researching approaches for this problem on and off for a year, so I didn&rsquo;t expect the problem to be slain in a day. Rather than giving up, I went searching for answers.</p><h2 id=enter-data-oriented-design>Enter Data-Oriented Design</h2><p>Recently I have been researching Data-Oriented Design. My first introduction to it was a great <a href=https://youtu.be/rX0ItVEVjHc target=_blank rel="noopener noreffer">talk by Mike Acton</a> as <a href=https://cppcon.org/ target=_blank rel="noopener noreffer">CppCon</a>. I regularly watch talks on other languages and paradigms to grow my understanding of the field and this talk in particular struck a chord. While some may find Mike&rsquo;s delivery a little brusque, I found it refreshing. The talk is littered with great lines, but the following is one of my favorite.</p><blockquote><p>Reality is not a hack you&rsquo;re forced to deal with to solve your abstract, theoretical problem. Reality is the actual problem.</p><p>Mike Acton</p></blockquote><p>Overall, Data-Oriented Design emphasizes data and its transformation as the key thing to design around. It generally eschews Object Orientation as a means of decomposing problems and instead looks at what data layouts and access patterns allow us to extract the maximum performance. This talk sent me deep down a rabbit hole. Eventually I found my way to Jonathan Blow who has given many great talks online. I decided to pick up the book <a href=https://www.amazon.com/Data-oriented-design-engineering-resources-schedules/dp/1916478700/ target=_blank rel="noopener noreffer">&ldquo;Data-Oriented Design&rdquo;</a> by <a href=https://twitter.com/raspofabs target=_blank rel="noopener noreffer">Richard Fabian</a>.</p><p>I&rsquo;m still struggling with how I could use Data-Oriented Design to solve my slicing problem when I came to chapter 6 which discusses Searching. On page 114 of the paperback Richard describes how we can have data structures for looking up data that keep track of the query patterns being used. Once a threshold is met, the data could be re-ordered to better suit how the data is being accessed.</p><p>This was the moment of insight for me. &ldquo;Wait!&rdquo; I said to myself. &ldquo;In real world use cases, you are often slicing across 1 dimension of the data many times in a row. Then you may start slicing across another dimension many times in a tight loop. Why not have the SliceMap re-order it&rsquo;s data to be optimal for the types of lookups that are being performed!&rdquo;</p><h2 id=idea-3-reorganizing-internals>Idea 3: Reorganizing Internals</h2><p>I went back to the drawing board and reworked how data was being stored in the <code>SliceMap</code> types. The internal fields of the 1 dimensional <code>SliceMap</code> remained simple. We give the <code>SliceMap</code> a comparer for comparing the keys when performing the Hadamard Product. <code>keys</code> is just a chunk of memory that is sorted. <code>values</code> is contiguous memory where the position is what determines the key it goes with.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>type</span> <span class=nc>SliceMap</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>k</span><span class=o>,</span> <span class=k>&#39;</span><span class=n>v</span> <span class=k>when</span> <span class=k>&#39;</span><span class=n>k</span> <span class=o>:</span> <span class=n>comparison</span><span class=o>&gt;</span> 
</span></span><span class=line><span class=cl>    <span class=o>(</span><span class=n>comparer</span><span class=o>:</span> <span class=n>IComparer</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>k</span><span class=o>&gt;,</span> 
</span></span><span class=line><span class=cl>     <span class=n>keys</span><span class=o>:</span> <span class=n>ReadOnlyMemory</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>k</span><span class=o>&gt;,</span> 
</span></span><span class=line><span class=cl>     <span class=n>values</span><span class=o>:</span> <span class=n>ReadOnlyMemory</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>v</span><span class=o>&gt;)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>comparer</span> <span class=o>=</span> <span class=n>comparer</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>keys</span> <span class=o>=</span> <span class=n>keys</span>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>values</span> <span class=o>=</span> <span class=n>values</span>
</span></span></code></pre></td></tr></table></div></div><p><code>SliceMap2D</code> gets a little more interesting. We need to remember that a <code>SliceMap2D</code> can be thought of as a table in a database where the primary key is made up of two fields: Key1 and Key2. Here is what some example data could look like.</p><table><thead><tr><th>Key1</th><th>Key2</th><th>Value</th></tr></thead><tbody><tr><td>1</td><td>&ldquo;A&rdquo;</td><td>2.0</td></tr><tr><td>1</td><td>&ldquo;B&rdquo;</td><td>8.0</td></tr><tr><td>1</td><td>&ldquo;C&rdquo;</td><td>3.0</td></tr><tr><td>2</td><td>&ldquo;B&rdquo;</td><td>1.7</td></tr><tr><td>2</td><td>&ldquo;C&rdquo;</td><td>1.7</td></tr><tr><td>3</td><td>&ldquo;A&rdquo;</td><td>9.4</td></tr><tr><td>3</td><td>&ldquo;B&rdquo;</td><td>4.6</td></tr><tr><td>&mldr;</td><td>&mldr;</td><td></td></tr></tbody></table><p>Since we are trying to optimize the speed of slicing the data, we are willing to do some work up front to organize the data. When we initially create the <code>SliceMap2D</code>, we will sort the data by Key1 then Key2. This will allow us to use <a href=https://en.wikipedia.org/wiki/Run-length_encoding target=_blank rel="noopener noreffer">Run Length Encoding</a> on the outer keys, Key1 in this case. We will store the length of the runs of the outer key in an <code>IndexRange</code> type.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>IndexRange</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Start</span> <span class=o>:</span> <span class=n>int</span>
</span></span><span class=line><span class=cl>    <span class=n>Length</span> <span class=o>:</span> <span class=n>int</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>We will use two arrays for storing Key1 data. One array for the values of Key1, another for the <code>IndexRange</code> that corresponds to the key. We will call these fields <code>OuterKeyValues</code> and <code>OuterKeyRanges</code> respectively. Key2 and Values will be stored in a <code>ReadOnlyMemory</code> of their respective types. Key2 and Values have a 1 to 1 matching based on their location in their containers. We can now define <code>SliceMap2DInternals</code> for storing this information.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>SliceMap2DInternals</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>k1</span><span class=o>,</span> <span class=k>&#39;</span><span class=n>k2</span><span class=o>,</span> <span class=k>&#39;</span><span class=n>v</span> <span class=k>when</span> <span class=k>&#39;</span><span class=n>k1</span> <span class=o>:</span> <span class=n>comparison</span> <span class=ow>and</span> <span class=k>&#39;</span><span class=n>k2</span> <span class=o>:</span> <span class=n>comparison</span><span class=o>&gt;</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>OuterComparer</span> <span class=o>:</span> <span class=n>IComparer</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>k1</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>InnerComparer</span> <span class=o>:</span> <span class=n>IComparer</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>k2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>OuterKeyValues</span> <span class=o>:</span> <span class=k>&#39;</span><span class=n>k1</span><span class=bp>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>OuterKeyRanges</span> <span class=o>:</span> <span class=n>IndexRange</span><span class=bp>[]</span>
</span></span><span class=line><span class=cl>    <span class=n>InnerKeyValues</span> <span class=o>:</span> <span class=n>ReadOnlyMemory</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>k2</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=n>Values</span> <span class=o>:</span> <span class=n>ReadOnlyMemory</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>v</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Now, you may notice that I was talking about Key1 and Key2 but then switched to talking about OuterKey and InnerKey. This is where things may get confusing but trust me, we&rsquo;ll get there! We need <code>SliceMap2D</code> to be able to restructure itself in order to provide fast slicing across Key1 or Key2. If Key1 data is stored in the OuterKey fields, then it is much faster to slice along Key1 because all we need to do it find the range of values it applies to and simply just slice the memory for <code>InnerKeyValues</code> and <code>Values</code> to create a <code>SliceMap</code>.</p><p>If Key2 is stored in the <code>InnerKeyValues</code> field, it is difficult to slice because a particular value of Key2 could occur in multiple places in <code>InnerKeyValues</code>. But what if we were able to flip which key was stored in the <code>OuterKeyValues</code> and <code>OuterKeyRanges</code> fields and which one was stored in <code>InnerKeyValues</code>? Well, then we could slice along the Key2 dimension quickly since all its values would be contiguous after flipping.</p><p>The &ldquo;problem&rdquo; is that F# is statically typed and doesn&rsquo;t like you changing the type of fields. Fortunately, every problem in F# is solved with another type. Enter the <code>SliceMap2DState</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>type</span> <span class=nc>SliceMap2DState</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>k1</span><span class=o>,</span> <span class=k>&#39;</span><span class=n>k2</span><span class=o>,</span> <span class=k>&#39;</span><span class=n>v</span> <span class=k>when</span> <span class=k>&#39;</span><span class=n>k1</span> <span class=o>:</span> <span class=n>comparison</span> <span class=ow>and</span> <span class=k>&#39;</span><span class=n>k2</span> <span class=o>:</span> <span class=n>comparison</span><span class=o>&gt;</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>Key1Key2</span> <span class=k>of</span> <span class=n>SliceMap2DInternals</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>k1</span><span class=o>,</span> <span class=k>&#39;</span><span class=n>k2</span><span class=o>,</span> <span class=k>&#39;</span><span class=n>v</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>Key2Key1</span> <span class=k>of</span> <span class=n>SliceMap2DInternals</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>k2</span><span class=o>,</span> <span class=k>&#39;</span><span class=n>k1</span><span class=o>,</span> <span class=k>&#39;</span><span class=n>v</span><span class=o>&gt;</span>
</span></span></code></pre></td></tr></table></div></div><p>What this Discriminated Union is doing is containing the information for how the keys are stored in the <code>SliceMap2DInternals</code>. It tells us if Key1 is in the outer fields or if Key2 is. Now we can define <code>SliceMap2D</code>.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>type</span> <span class=nc>SliceMap2D</span><span class=o>&lt;</span><span class=k>&#39;</span><span class=n>k1</span><span class=o>,</span> <span class=k>&#39;</span><span class=n>k2</span><span class=o>,</span> <span class=k>&#39;</span><span class=n>v</span> <span class=k>when</span> <span class=k>&#39;</span><span class=n>k1</span> <span class=o>:</span> <span class=n>comparison</span> <span class=ow>and</span> <span class=k>&#39;</span><span class=n>k2</span> <span class=o>:</span> <span class=n>comparison</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl>    <span class=o>(</span><span class=n>internalState</span><span class=o>:</span> <span class=n>SliceMap2DState</span><span class=o>&lt;_,</span> <span class=o>_,</span> <span class=o>_&gt;)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>let</span> <span class=nv>mutable</span> <span class=n>internalState</span> <span class=o>=</span> <span class=n>internalState</span>
</span></span></code></pre></td></tr></table></div></div><p>Notice, <code>SliceMap2D</code> is storing its state in a mutable field so it can change it when it wants. When you go to slice along a dimension, it will check how the data is laid out. If the data is not laid out for efficient slicing, it will swap the keys around. Here is what the slicing method looks like.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl>    <span class=k>member</span> <span class=n>_</span><span class=p>.</span><span class=nf>Item</span>
</span></span><span class=line><span class=cl>        <span class=c1>// Ignoring `f` at this time
</span></span></span><span class=line><span class=cl><span class=c1></span>        <span class=k>with</span> <span class=n>get</span> <span class=o>(</span><span class=n>x</span><span class=o>:</span> <span class=k>&#39;</span><span class=n>k1</span><span class=o>,</span> <span class=n>f</span><span class=o>:</span> <span class=n>Filter</span><span class=o>)</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// Get the internals
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>let</span> <span class=nv>internals</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Check which state the internals are in
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>match</span> <span class=n>internalState</span> <span class=k>with</span>
</span></span><span class=line><span class=cl>                <span class=c1>// This is the ideal state for serving up this slice so do nothing
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=o>|</span> <span class=nn>SliceMap2DState</span><span class=p>.</span><span class=n>Key1Key2</span> <span class=n>i</span> <span class=o>-&gt;</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>                <span class=c1>// If the internals are in this state, we will swap the keys so
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// that slicing can be fast
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=o>|</span> <span class=nn>SliceMap2DState</span><span class=p>.</span><span class=n>Key2Key1</span> <span class=n>i</span> <span class=o>-&gt;</span> 
</span></span><span class=line><span class=cl>                    <span class=k>let</span> <span class=nv>reOrdered</span> <span class=o>=</span> <span class=nn>SliceMap2DInternals</span><span class=p>.</span><span class=n>swapKeys</span> <span class=n>i</span>
</span></span><span class=line><span class=cl>                    <span class=n>internalState</span> <span class=o>&lt;-</span> <span class=nn>SliceMap2DState</span><span class=p>.</span><span class=n>Key1Key2</span> <span class=n>reOrdered</span>
</span></span><span class=line><span class=cl>                    <span class=n>reOrdered</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>mutable</span> <span class=n>intervalIdx</span> <span class=o>=</span> <span class=mi>0</span>
</span></span><span class=line><span class=cl>            <span class=k>let</span> <span class=nv>mutable</span> <span class=n>keepSearching</span> <span class=o>=</span> <span class=k>true</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=c1>// Perform a scan to find the matching key. We&#39;ll come back to this ðŸ˜‰
</span></span></span><span class=line><span class=cl><span class=c1></span>            <span class=k>while</span> <span class=n>keepSearching</span> <span class=o>&amp;&amp;</span> <span class=n>intervalIdx</span> <span class=o>&lt;</span> <span class=n>internals</span><span class=o>.</span><span class=n>OuterKeyValues</span><span class=o>.</span><span class=n>Length</span> <span class=o>-</span> <span class=mi>1</span> <span class=k>do</span>
</span></span><span class=line><span class=cl>                <span class=k>if</span> <span class=n>internals</span><span class=o>.</span><span class=n>OuterComparer</span><span class=o>.</span><span class=n>Compare</span> <span class=o>(</span><span class=n>internals</span><span class=o>.</span><span class=n>OuterKeyValues</span><span class=o>[</span><span class=n>intervalIdx</span><span class=o>],</span> <span class=n>x</span><span class=o>)</span> <span class=o>=</span> <span class=mi>0</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>                    <span class=n>keepSearching</span> <span class=o>&lt;-</span> <span class=k>false</span>
</span></span><span class=line><span class=cl>                <span class=k>else</span>
</span></span><span class=line><span class=cl>                    <span class=n>intervalIdx</span> <span class=o>&lt;-</span> <span class=n>intervalIdx</span> <span class=o>+</span> <span class=mi>1</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>            <span class=k>if</span> <span class=ow>not</span> <span class=n>keepSearching</span> <span class=k>then</span>
</span></span><span class=line><span class=cl>                <span class=c1>// The key was found, and we can slice the contiguous data
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>let</span> <span class=nv>interval</span> <span class=o>=</span> <span class=n>internals</span><span class=o>.</span><span class=n>OuterKeyRanges</span><span class=o>[</span><span class=n>intervalIdx</span><span class=o>]</span>
</span></span><span class=line><span class=cl>                <span class=c1>// We have ensured that the pertinent data is contiguous so we can use
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=c1>// slicing to get the necessary data
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=k>let</span> <span class=nv>newKeys</span> <span class=o>=</span> <span class=n>internals</span><span class=o>.</span><span class=n>InnerKeyValues</span><span class=o>.</span><span class=n>Slice</span> <span class=o>(</span><span class=n>interval</span><span class=o>.</span><span class=n>Start</span><span class=o>,</span> <span class=n>interval</span><span class=o>.</span><span class=n>Length</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=k>let</span> <span class=nv>newValues</span> <span class=o>=</span> <span class=n>internals</span><span class=o>.</span><span class=n>Values</span><span class=o>.</span><span class=n>Slice</span> <span class=o>(</span><span class=n>interval</span><span class=o>.</span><span class=n>Start</span><span class=o>,</span> <span class=n>interval</span><span class=o>.</span><span class=n>Length</span><span class=o>)</span>
</span></span><span class=line><span class=cl>                <span class=c1>// Return a SliceMap with the data slice
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>SliceMap</span> <span class=o>(</span><span class=n>internals</span><span class=o>.</span><span class=n>InnerComparer</span><span class=o>,</span> <span class=n>newKeys</span><span class=o>,</span> <span class=n>newValues</span><span class=o>)</span>
</span></span><span class=line><span class=cl>            <span class=k>else</span>
</span></span><span class=line><span class=cl>                <span class=c1>// The key was not found, return an empty SliceMap
</span></span></span><span class=line><span class=cl><span class=c1></span>                <span class=n>SliceMap</span> <span class=o>(</span><span class=n>internals</span><span class=o>.</span><span class=n>InnerComparer</span><span class=o>,</span> <span class=n>ReadOnlyMemory</span> <span class=nn>Array</span><span class=p>.</span><span class=n>empty</span><span class=o>,</span> <span class=n>ReadOnlyMemory</span> <span class=nn>Array</span><span class=p>.</span><span class=n>empty</span><span class=o>)</span>
</span></span></code></pre></td></tr></table></div></div><p>The reason this is a valid optimization is that <code>SliceMap</code> was never intended as a general-purpose data structure. It was built to make composing Mathematical Planning problems clean and simple. When creating constraints, the dominant usage pattern is to perform the same slice many times for different values. Honestly, I put too much functionality into the original <code>SliceMap</code>. I lost focus on what the real problem was. You can see our solution up to this point at this <a href=https://github.com/matthewcrews/SliceMapPerformanceExploration/tree/step04-array-internals target=_blank rel="noopener noreffer">repo and branch</a>.</p><h2 id=did-we-get-faster>Did We Get Faster?</h2><p>In the previous post we ran our benchmarks against the current implementation, and we got the following timings.</p><table><thead><tr><th>Method</th><th style=text-align:right>Mean</th><th style=text-align:right>Error</th><th style=text-align:right>StdDev</th></tr></thead><tbody><tr><td>DenseData</td><td style=text-align:right>7.993 s</td><td style=text-align:right>0.0748 s</td><td style=text-align:right>0.0700 s</td></tr><tr><td>MediumSparsity</td><td style=text-align:right>2.154 s</td><td style=text-align:right>0.0176 s</td><td style=text-align:right>0.0156 s</td></tr><tr><td>HighSparsity</td><td style=text-align:right>1.209 s</td><td style=text-align:right>0.0134 s</td><td style=text-align:right>0.0126 s</td></tr></tbody></table><p>These are the timings we get for our new version of <code>SliceMap2D</code> with self-adjusting internals.</p><table><thead><tr><th>Method</th><th style=text-align:right>Mean</th><th style=text-align:right>Error</th><th style=text-align:right>StdDev</th></tr></thead><tbody><tr><td>DenseData</td><td style=text-align:right>379.05 ms</td><td style=text-align:right>5.281 ms</td><td style=text-align:right>4.940 ms</td></tr><tr><td>MediumSparsity</td><td style=text-align:right>113.99 ms</td><td style=text-align:right>0.647 ms</td><td style=text-align:right>0.574 ms</td></tr><tr><td>HighSparsity</td><td style=text-align:right>71.89 ms</td><td style=text-align:right>0.636 ms</td><td style=text-align:right>0.595 ms</td></tr></tbody></table><p>It looks a little better when we plot the performance against each other.</p><p><img class=lazyload src=/svg/loading.min.svg data-src=/blog/2021/08/slicemap-rework-part-2/SliceMapPerformanceDifference.PNG data-srcset="/blog/2021/08/slicemap-rework-part-2/SliceMapPerformanceDifference.PNG, /blog/2021/08/slicemap-rework-part-2/SliceMapPerformanceDifference.PNG 1.5x, /blog/2021/08/slicemap-rework-part-2/SliceMapPerformanceDifference.PNG 2x" data-sizes=auto alt=/blog/2021/08/slicemap-rework-part-2/SliceMapPerformanceDifference.PNG title="SliceMap Performance Difference" width=1043 height=614></p><p>So, it got a little faster ðŸ˜Š. I almost cried when I saw this. The fact that this problem has been tormenting me for over a year problem had something to do with it. We have even more gains on the horizon! There are several other things we can do to speed this up. Feel free to check out this <a href=https://github.com/matthewcrews/SliceMapPerformanceExploration/tree/step04-array-internals target=_blank rel="noopener noreffer">repo and branch</a> to see what all of the code looks like and run the benchmarks for yourself! I welcome feedback and ideas!</p><p>Please send me an email at <a href=mailto:matthewcrews@gmail.com rel>matthewcrews@gmail.com</a> if you have any questions and subscribe so you can stay on top new posts and products I am offering.</p><script>window.mootrack||!function(e,t,n,s,o){function i(e){var s,o=~~(Date.now()/3e5),t=document.createElement(n);t.async=!0,t.src=e+"?ts="+o,s=document.getElementsByTagName(n)[0],s.parentNode.insertBefore(t,s)}e.MooTrackerObject=o,e[o]=e[o]||function(){return e[o].q?void e[o].q.push(arguments):void(e[o].q=[arguments])},window.attachEvent?window.attachEvent("onload",i.bind(this,s)):window.addEventListener("load",i.bind(this,s),!1)}(window,document,"script","https://cdn.stat-track.com/statics/moosend-tracking.min.js","mootrack"),mootrack("loadForm","b498d29aaba84b5bb3e0479003dc7264")</script><div data-mooform-id=b498d29a-aba8-4b5b-b3e0-479003dc7264></div></div><div id=comments></div></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.111.3">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2019 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=matthewcrews.com target=_blank>Matthew Crews</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"PASDMWALPK",algoliaIndex:"index.en",algoliaSearchKey:"b42948e51daaa93df92381c8e2ac0f93",highlightTag:"em",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>