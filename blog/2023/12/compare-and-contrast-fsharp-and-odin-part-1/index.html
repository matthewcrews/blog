<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>- Matthew Crews</title><meta name=Description content="Hugo theme - LoveIt"><meta property="og:title" content>
<meta property="og:description" content="Compare and Contrast F# and Odin - Part 1 I have recently been talking online about the need to improve the importance of my .NET code. I have successfully created high-performance solutions using purely F# and will continue to. There comes a point, though, when you are fighting the system you are building on so much that you end up looking for another tool.
I have long been a programming language geek and have enjoyed learning about other languages and the problems that motivated them."><meta property="og:type" content="article"><meta property="og:url" content="https://matthewcrews.com/blog/2023/12/compare-and-contrast-fsharp-and-odin-part-1/"><meta property="og:image" content="https://matthewcrews.com/logo.png"><meta property="article:section" content="blog"><meta property="article:modified_time" content="2023-12-17T00:21:52-08:00"><meta property="og:site_name" content="Matthew Crews"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://matthewcrews.com/logo.png"><meta name=twitter:title content><meta name=twitter:description content="Compare and Contrast F# and Odin - Part 1 I have recently been talking online about the need to improve the importance of my .NET code. I have successfully created high-performance solutions using purely F# and will continue to. There comes a point, though, when you are fighting the system you are building on so much that you end up looking for another tool.
I have long been a programming language geek and have enjoyed learning about other languages and the problems that motivated them."><meta name=twitter:site content="@xxxx"><meta name=application-name content="Mathew Crews"><meta name=apple-mobile-web-app-title content="Mathew Crews"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://matthewcrews.com/blog/2023/12/compare-and-contrast-fsharp-and-odin-part-1/><link rel=next href=https://matthewcrews.com/blog/2018/2018-01-05-using-fsharp-to-parse-html/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"","inLanguage":"en","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/matthewcrews.com\/blog\/2023\/12\/compare-and-contrast-fsharp-and-odin-part-1\/"},"image":[{"@type":"ImageObject","url":"https:\/\/matthewcrews.com\/images\/Apple-Devices-Preview.png","width":3200,"height":2048}],"genre":"blog","wordcount":1984,"url":"https:\/\/matthewcrews.com\/blog\/2023\/12\/compare-and-contrast-fsharp-and-odin-part-1\/","dateModified":"2023-12-17T00:21:52-08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"xxxx","logo":"https:\/\/matthewcrews.com\/images\/fast_fsharp_avatar.png"},"author":{"@type":"Person","name":"Matthew Crews"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title="Matthew Crews">Matthew Crews</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/blog/>Blog </a><a class=menu-item href=/about/>About </a><a class=menu-item href=https://github.com/matthewcrews/blog title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i> </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder="Search titles or contents..." id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme"><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title="Matthew Crews">Matthew Crews</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder="Search titles or contents..." id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=Search><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=Clear><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>Cancel</a></div><a class=menu-item href=/blog/ title>Blog</a><a class=menu-item href=/about/ title>About</a><a class=menu-item href=https://github.com/matthewcrews/blog title=GitHub rel="noopener noreffer" target=_blank><i class='fab fa-github fa-fw' aria-hidden=true></i></a><a href=javascript:void(0); class="menu-item theme-switch" title="Switch Theme">
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class="page single special"><h1 class="single-title animate__animated animate__pulse animate__faster"></h1><div class=content id=content><h1 id=compare-and-contrast-f-and-odin---part-1>Compare and Contrast F# and Odin - Part 1</h1><p>I have recently been talking online about the need to improve the importance of my .NET code. I have successfully created high-performance solutions using purely F# and will continue to. There comes a point, though, when you are fighting the system you are building on so much that you end up looking for another tool.</p><p>I have long been a programming language geek and have enjoyed learning about other languages and the problems that motivated them. Early in my career, I prized productivity more than anything else, and to be honest, I still do. What makes a language productive is how well it fits your problem space. F# is a high-productivity language for many problem domains and will remain in my toolbox for a long time. I have reached the point where I need to push the performance of the product I am building, and the .NET platform doesn&rsquo;t fit anymore.</p><p>While exploring other languages, I landed on <a href=https://odin-lang.org/ target=_blank rel="noopener noreffer">Odin</a>, a language developer by Bill Hall (aka Ginger Bill). Odin appears to be a language purpose-built for the domain that I am working in. As I have started diving into Odin code, I thought it would be valuable to provide a compare and contrast of the two languages. Spoiler: neither language is superior to the other. To judge a language fairly, you must consider the problem space it is trying to address. F# and Odin have different goals, which I want to highlight.</p><p>Fortunately, the .NET runtime and F# make it easy to call Odin from F# so a solution doesn&rsquo;t have to be completely one or the other. The current project I am working on has an F# shell and an Odin core. We leverage both languages for what they are best at.</p><h2 id=the-goal-of-f>The Goal of F#</h2><p>From my understanding, the goal of F# was to provide a high-productivity language in the ML family for .NET. If you want to know the history, check out the <a href rel>HOPL paper</a>. It gives a detailed history of how the language came to be and the forces that shaped it. I think of F# as a language designed to get work done; it just happens to have a functional flare to it. It leans toward immutability and composing solutions by defining types and functions that operate on those types. In 99% of scenarios, you can achieve excellent performance with F#. It wants to simplify developers’ lives so it has safe and robust defaults. Being built on top of .NET it has Garbage Collection, which is a boon to developers who don&rsquo;t want to care about managing memory (more on this later).</p><p>F# has a terse syntax that provides minimal noise and gets out of your way. It also has access to the enormous .NET ecosystem which can help bootstrap any project. I still believe F# is an excellent first language, and if I need to &ldquo;just get something done,&rdquo; F# is still my preferred tool. It has excellent tooling, and debugging is straightforward due to the language’s design dragging you down the pit of success.</p><h2 id=the-goal-of-odin>The Goal of Odin</h2><p>Odin started in July 2016, born out of Bill Hall’s frustration with the C and C++ languages. I recommend <a href="https://youtu.be/rCqFdYUnC24?si=XdL0uAsqvWDriszi" target=_blank rel="noopener noreffer">this video</a> for a quick introduction to the language. Bill&rsquo;s background is in Physics, and he has many years of programming experience. He&rsquo;s currently employed by <a href=https://jangafx.com/ target=_blank rel="noopener noreffer">JangaFX</a>, which develops real-time simulation engines for movies and video games. I won&rsquo;t put words in Bill&rsquo;s mouth, so the following is my synopsis of Odin.</p><p>I see Odin as one of the C-Next languages. It is very purposefully not intended as a successor to C++. I think this is an important distinction. Many of the other languages I have looked at appeared to be more interested in becoming the next C++. I would put Rust, Jai, Nim, and Vale in this category. Odin is conservative in its feature set; it just does it very well. This may not seem impressive, but there is something incredibly pleasing about using an extremely well-made tool.</p><p>Odin is intended as a language for high-performance computing. You can see that in its extensive support for memory allocators and controlling memory layout. Including the Struct of Array layout using <code>#soa</code> and the <code>using</code> keyword makes it easy to play with how your data is laid out and accessed.</p><p>Odin intends to make writing high-performance code joyful, and I can tell you it succeeds wildly after working in it for a couple of weeks.</p><p>Let&rsquo;s now start comparing these languages and discussing their differences.</p><h2 id=defining-types>Defining Types</h2><h3 id=records-and-structs>Records and Structs</h3><p>Both F# and Odin make it easy to define types. The most significant difference is that F# defaults to creating objects on the heap, while Odin defaults to the stack. Let&rsquo;s define a <code>Chicken</code> type in both languages. The default for F# would be to define <code>Chicken</code> as a Record, an immutable and heterogenous collection of fields allocated on the Heap.</p><p>F#</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>type</span> <span class=nc>Chicken</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Name</span><span class=o>:</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=n>Age</span><span class=o>:</span> <span class=n>int</span>
</span></span><span class=line><span class=cl>    <span class=n>Size</span><span class=o>:</span> <span class=kt>float</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Odin doesn&rsquo;t have the idea of a Record. Instead, the closest thing we have is a <code>struct</code> which is allocated on the Stack.</p><p>Odin</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-odin data-lang=odin><span class=line><span class=cl><span class=n>Chicken</span><span class=w> </span><span class=o>::</span><span class=w> </span><span class=kd>struct</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Name</span><span class=o>:</span><span class=w> </span><span class=kt>string</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Age</span><span class=o>:</span><span class=w> </span><span class=kt>i32</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>Size</span><span class=o>:</span><span class=w> </span><span class=kt>f64</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>You see that it is nearly the same. To define <code>Chicken</code> as a struct in F#, you need to add the <code>[&lt;Struct>]</code> attribute.</p><p>F#</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>Chicken</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=n>Name</span><span class=o>:</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=n>Age</span><span class=o>:</span> <span class=n>int</span>
</span></span><span class=line><span class=cl>    <span class=n>Size</span><span class=o>:</span> <span class=kt>float</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Note that the F# <code>Chicken</code> is immutable. You cannot change the values of the fields. If you want to do that, you need to add the <code>mutable</code> keyword.</p><p>F#</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=o>[&lt;</span><span class=n>Struct</span><span class=o>&gt;]</span>
</span></span><span class=line><span class=cl><span class=k>type</span> <span class=nc>Chicken</span> <span class=o>=</span> <span class=o>{</span>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>Name</span><span class=o>:</span> <span class=kt>string</span>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>Age</span><span class=o>:</span> <span class=n>int</span>
</span></span><span class=line><span class=cl>    <span class=k>mutable</span> <span class=n>Size</span><span class=o>:</span> <span class=kt>float</span>
</span></span><span class=line><span class=cl><span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>This is unusual in F#. Generally, if you wanted an updated version of a Record, you would use the <code>with</code> syntax to update the appropriate fields. Here&rsquo;s an example of creating a new instance of <code>Chicken</code> with a new name value of &ldquo;Drumstick&rdquo;.</p><p>F#</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=nv>c1</span> <span class=o>=</span> <span class=o>{</span> <span class=n>Name</span> <span class=o>=</span> <span class=s>&#34;Clucky&#34;</span><span class=o>;</span> <span class=n>Age</span> <span class=o>=</span> <span class=n>1</span><span class=o>;</span> <span class=n>Size</span> <span class=o>=</span> <span class=n>2</span><span class=o>.</span><span class=n>0</span> <span class=o>}</span>
</span></span><span class=line><span class=cl><span class=k>let</span> <span class=nv>newChicken</span> <span class=o>=</span> <span class=o>{</span> <span class=n>c1</span> <span class=k>with</span> <span class=n>Name</span> <span class=o>=</span> <span class=s>&#34;Drumstick&#34;</span> <span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>If you add the <code>mutable</code> keyword to each of the fields of <code>Chicken</code> you now have something equivalent to the Odin <code>Chicken</code>.</p><p>Let&rsquo;s compare the syntax for creating an instance of <code>Chicken</code> in F# and Odin.</p><p>F#</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=nv>c</span> <span class=o>=</span> <span class=o>{</span> <span class=n>Name</span> <span class=o>=</span> <span class=s>&#34;Clucky&#34;</span><span class=o>;</span> <span class=n>Age</span> <span class=o>=</span> <span class=n>1</span><span class=o>;</span> <span class=n>Size</span> <span class=o>=</span> <span class=n>2</span><span class=o>.</span><span class=n>0</span> <span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>Odin</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-odin data-lang=odin><span class=line><span class=cl><span class=n>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=n>Chicken</span><span class=p>{</span><span class=w> </span><span class=s>&#34;Clucky&#34;</span><span class=p>,</span><span class=w> </span><span class=nx>1</span><span class=p>,</span><span class=w> </span><span class=nx>2</span><span class=mf>.0</span><span class=p>,</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>You will see in this case that the F# is a little more verbose. This is because Odin allows you to create instances of <code>struct</code>s by providing arguments in the order they are declared. If you wanted to be more explicit, you could use the field names as well:</p><p>Odin</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-odin data-lang=odin><span class=line><span class=cl><span class=n>c</span><span class=w> </span><span class=o>:=</span><span class=w> </span><span class=p>{</span><span class=w> </span><span class=n>Name</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&#34;Clucky&#34;</span><span class=p>,</span><span class=w> </span><span class=n>Age</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>1</span><span class=p>,</span><span class=w> </span><span class=n>Size</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nx>2</span><span class=mf>.0</span><span class=p>,</span><span class=w> </span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>If we use the default <code>let</code> binding in F#, we still won&rsquo;t have quite the same behavior as Odin. Though the fields of the F# <code>Chicken</code> type are mutable, we aren&rsquo;t allowed to change them without taking a mutable binding. Let&rsquo;s do the Odin equivalent in F#.</p><p>F#</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>let</span> <span class=nv>mutable</span> <span class=n>c</span> <span class=o>=</span> <span class=o>{</span> <span class=n>Name</span> <span class=o>=</span> <span class=s>&#34;Clucky&#34;</span><span class=o>;</span> <span class=n>Age</span> <span class=o>=</span> <span class=n>1</span><span class=o>;</span> <span class=n>Size</span> <span class=o>=</span> <span class=n>2</span><span class=o>.</span><span class=n>0</span> <span class=o>}</span>
</span></span></code></pre></td></tr></table></div></div><p>We now have something that behaves exactly like the Odin <code>Chicken</code>. Now, is the Odin version of the F# version better? Before you even think about that question, you must ask, “Under what criteria are we judging these languages?" In a later post, I will dive more into this. For now, I want you to observe what F# makes easy and what Odin makes easy. That will inform the design intention behind these languages and, therefore, how we should judge them.</p><p>I showed you how to express the F# <code>Chicken</code> with the same functionality as the Odin <code>Chicken</code>. Notice that I did not do the inverse. From my limited knowledge, it&rsquo;s impossible to express the idea of immutable types in Odin, which makes sense given the roots of the language. Let&rsquo;s move on to Discriminated Unions.</p><h3 id=discriminated-unions>Discriminated Unions</h3><p>Both F# and Odin have algebraic type systems, meaning they have “AND” and &ldquo;OR&rdquo; types. An F# Record or Odin <code>struct</code> are AND types. You can think of a <code>Chicken</code> as being a &ldquo;Name&rdquo; <strong>and</strong> an &ldquo;Age&rdquo; <strong>and</strong> a &ldquo;Size&rdquo;. An OR type is one where you have a type which could be a Foo <strong>or</strong> a Bar <strong>or</strong> a Baz. Let&rsquo;s say we wanted to define a type <code>Value</code> which could be an <code>int</code>, <code>float</code>, or <code>string</code>. In F#, we would use a Discriminated Union (DU) like so:</p><p>F#</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>type</span> <span class=nc>Value</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>A</span> <span class=k>of</span> <span class=n>int</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>B</span> <span class=k>of</span> <span class=kt>float</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>C</span> <span class=k>of</span> <span class=kt>string</span>
</span></span></code></pre></td></tr></table></div></div><p>An F# DU requires that each case of the DU have a label and a type associated with the label. The labels in this example are &ldquo;A&rdquo;, &ldquo;B&rdquo;, and &ldquo;C&rdquo;. The value associated with &ldquo;A&rdquo; is an <code>int</code>, the value associated with &ldquo;B&rdquo; is a <code>float</code>, and the value associated with the label &ldquo;C&rdquo; is a <code>string</code>. Odin&rsquo;s DUs are just called Unions and are similar to F# but drop the Label. Only types make up the cases of a Union in Odin. Here is what <code>Value</code> looks like in Odin:</p><p>Odin</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-odin data-lang=odin><span class=line><span class=cl><span class=n>Value</span><span class=w> </span><span class=o>::</span><span class=w> </span><span class=kd>union</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=kt>i32</span><span class=p>,</span><span class=w> </span><span class=c1>// Equivalent to the F# `int`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kt>f64</span><span class=p>,</span><span class=w> </span><span class=c1>// Equivalent to the F# `float`
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w>    </span><span class=kt>string</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>The lack of labels means that the following F# cannot be expressed in Odin.</p><p>F#</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>type</span> <span class=nc>OtherValue</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>Case1</span> <span class=k>of</span> <span class=n>int</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>Case2</span> <span class=k>of</span> <span class=n>int</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>Case3</span> <span class=k>of</span> <span class=n>int</span>
</span></span></code></pre></td></tr></table></div></div><p>The <code>OtherValue</code> type has three possible cases, but the underlying type is always an <code>int</code>. This can&rsquo;t be written in Odin since the Union type in Odin only comprises types. This may sound bad, but Odin has another trick: the <code>distinct</code> types. Odin is described as a distinctly typed language, which means that just because two types share the exact same underlying representation, they should not be considered equivalent types. What makes this easy is having a <code>distinct</code> keyword. <code>distinct</code> allows you to define a new type with the same data representation as another type, but the compiler does not consider them interchangeable. Let’s see this in action.</p><p>We return to our F# example and say that the different cases correspond to IDs in our domain. Instead of defining our union as <code>OtherValue</code>, we are going to say it is a <code>BirdId</code> which could be holding the Id for three different kinds of birds: Chicken, Turkey, and Goose.</p><p>F#</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fsharp data-lang=fsharp><span class=line><span class=cl><span class=k>type</span> <span class=nc>BirdId</span> <span class=o>=</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>ChickenId</span> <span class=k>of</span> <span class=n>int</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>TurkeyId</span> <span class=k>of</span> <span class=n>int</span>
</span></span><span class=line><span class=cl>    <span class=o>|</span> <span class=n>GooseId</span> <span class=k>of</span> <span class=n>int</span>
</span></span></code></pre></td></tr></table></div></div><p>How do we do something like this in Odin? We use the <code>distinct</code> keyword.</p><p>Odin</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-odin data-lang=odin><span class=line><span class=cl><span class=n>ChickenId</span><span class=w> </span><span class=o>::</span><span class=w> </span><span class=k>distinct</span><span class=w> </span><span class=kt>i32</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>TurkeyId</span><span class=w> </span><span class=o>::</span><span class=w> </span><span class=k>distinct</span><span class=w> </span><span class=kt>i32</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>GooseId</span><span class=w> </span><span class=o>::</span><span class=w> </span><span class=k>distinct</span><span class=w> </span><span class=kt>i32</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>BirdId</span><span class=w> </span><span class=o>::</span><span class=w> </span><span class=kd>union</span><span class=w> </span><span class=p>{</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>ChickenId</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>TurkeyId</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=n>GooseId</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=p>}</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>Even though all of these IDs use an <code>int</code> as the underlying value, we have told Odin that it should consider them distinct. I have found the combination of <code>distinct</code> with union to solve any issues with not having labels for the different cases. In F#, you would likely use a single-case DU to wrap the <code>int</code> values to differentiate them.</p><h2 id=next-time>Next Time</h2><p>In the next post, we’ll discuss functions and procedures and how F# and Odin differ. I hope by the end, you’ll have a deeper appreciation for both languages and understand how their different design goals formed their evolution. You’ll understand their strengths and weaknesses and see how being able to use both of them can lead to incredibly powerful solutions.</p></div><div id=comments></div></div></div></main><footer class=footer><div class=footer-container><div class=footer-line>Powered by <a href=https://gohugo.io/ target=_blank rel="noopener noreffer" title="Hugo 0.121.1">Hugo</a> | Theme - <a href=https://github.com/dillonzq/LoveIt target=_blank rel="noopener noreffer" title="LoveIt 0.2.11"><i class="far fa-kiss-wink-heart fa-fw" aria-hidden=true></i> LoveIt</a></div><div class=footer-line itemscope itemtype=http://schema.org/CreativeWork><i class="far fa-copyright fa-fw" aria-hidden=true></i><span itemprop=copyrightYear>2019 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=matthewcrews.com target=_blank>Matthew Crews</a></span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title="Back to Top"><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title="View Comments"><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/algoliasearch@4.13.1/dist/algoliasearch-lite.umd.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.5.1/sharer.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/auto-render.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/copy-tex.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/contrib/mhchem.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"Copy to clipboard",maxShownLines:50},comment:{},math:{delimiters:[{display:!0,left:"$$",right:"$$"},{display:!0,left:"\\[",right:"\\]"},{display:!0,left:"\\begin{equation}",right:"\\end{equation}"},{display:!0,left:"\\begin{equation*}",right:"\\end{equation*}"},{display:!0,left:"\\begin{align}",right:"\\end{align}"},{display:!0,left:"\\begin{align*}",right:"\\end{align*}"},{display:!0,left:"\\begin{alignat}",right:"\\end{alignat}"},{display:!0,left:"\\begin{alignat*}",right:"\\end{alignat*}"},{display:!0,left:"\\begin{gather}",right:"\\end{gather}"},{display:!0,left:"\\begin{CD}",right:"\\end{CD}"},{display:!1,left:"$",right:"$"},{display:!1,left:"\\(",right:"\\)"}],strict:!1},search:{algoliaAppID:"PASDMWALPK",algoliaIndex:"index.en",algoliaSearchKey:"b42948e51daaa93df92381c8e2ac0f93",highlightTag:"em",maxResultLength:10,noResultsFound:"No results found",snippetLength:30,type:"algolia"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>